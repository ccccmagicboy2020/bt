C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\Objects\system.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\system.c COMPACT BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\system.lst) TABS(2) OBJECT(.\Objects\system.obj)

line level    source

   1          /****************************************Copyright (c)*************************
   2          **                               版权所有 (C), 2015-2017, 涂鸦科技
   3          **
   4          **                                 http://www.tuya.com
   5          **
   6          **--------------文件信息-------------------------------------------------------
   7          **文   件   名: system.c
   8          **描        述: bluetooth数据处理函数
   9          **使 用 说 明 : 用户无需关心该文件实现内容
  10          **
  11          **
  12          **--------------当前版本修订---------------------------------------------------
  13          ** 版  本: v1.0
  14          ** 日　期: 2017年5月3日
  15          ** 描　述: 1:创建涂鸦bluetooth对接MCU_SDK
  16          **
  17          **-----------------------------------------------------------------------------
  18          ******************************************************************************/
  19          #define SYSTEM_GLOBAL
  20          
  21          #include "bluetooth.h"
  22          //
  23          //
  24          extern const DOWNLOAD_CMD_S download_cmd[];
  25          
  26          /*****************************************************************************
  27          函数名称 : set_bt_uart_byte
  28          功能描述 : 写bt_uart字节
  29          输入参数 : dest:缓存区其实地址;
  30                     byte:写入字节值
  31          返回参数 : 写入完成后的总长度
  32          *****************************************************************************/
  33          unsigned short set_bt_uart_byte(unsigned short dest, unsigned char byte)
  34          {
  35   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  36   1        
  37   1        *obj = byte;
  38   1        dest += 1;
  39   1        
  40   1        return dest;
  41   1      }
  42          /*****************************************************************************
  43          函数名称 : set_bt_uart_buffer
  44          功能描述 : 写bt_uart_buffer
  45          输入参数 : dest:目标地址
  46                     src:源地址
  47                     len:数据长度
  48          返回参数 : 无
  49          *****************************************************************************/
  50          unsigned short set_bt_uart_buffer(unsigned short dest, unsigned char *src, unsigned short len)
  51          {
  52   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  53   1        
  54   1        my_memcpy(obj,src,len);
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 2   

  55   1        
  56   1        dest += len;
  57   1        return dest;
  58   1      }
  59          /*****************************************************************************
  60          函数名称 : bt_uart_write_data
  61          功能描述 : 向bt uart写入连续数据
  62          输入参数 : in:发送缓存指针
  63                     len:数据发送长度
  64          返回参数 : 无
  65          *****************************************************************************/
  66          static void bt_uart_write_data(unsigned char *in, unsigned short len)
  67          {
  68   1        if((NULL == in) || (0 == len))
  69   1        {
  70   2          return;
  71   2        }
  72   1        
  73   1        while(len --)
  74   1        {
  75   2          uart_transmit_output(*in);
  76   2          in ++;
  77   2        }
  78   1      }
  79          /*****************************************************************************
  80          函数名称 : get_check_sum
  81          功能描述 : 计算校验和
  82          输入参数 : pack:数据源指针
  83                     pack_len:计算校验和长度
  84          返回参数 : 校验和
  85          *****************************************************************************/
  86          unsigned char get_check_sum(unsigned char *pack, unsigned short pack_len)
  87          {
  88   1        unsigned short i;
  89   1        unsigned char check_sum = 0;
  90   1        
  91   1        for(i = 0; i < pack_len; i ++)
  92   1        {
  93   2          check_sum += *pack ++;
  94   2        }
  95   1        
  96   1        return check_sum;
  97   1      }
  98          /*****************************************************************************
  99          函数名称 : bt_uart_write_frame
 100          功能描述 : 向bt串口发送一帧数据
 101          输入参数 : fr_type:帧类型
 102                     len:数据长度
 103          返回参数 : 无
 104          *****************************************************************************/
 105          void bt_uart_write_frame(unsigned char fr_type, unsigned short len)
 106          {
 107   1        unsigned char check_sum = 0;
 108   1        
 109   1        bt_uart_tx_buf[HEAD_FIRST] = 0x55;
 110   1        bt_uart_tx_buf[HEAD_SECOND] = 0xaa;
 111   1        bt_uart_tx_buf[PROTOCOL_VERSION] = 0x00;
 112   1        bt_uart_tx_buf[FRAME_TYPE] = fr_type;
 113   1        bt_uart_tx_buf[LENGTH_HIGH] = len >> 8;
 114   1        bt_uart_tx_buf[LENGTH_LOW] = len & 0xff;
 115   1        
 116   1        len += PROTOCOL_HEAD;
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 3   

 117   1        check_sum = get_check_sum((unsigned char *)bt_uart_tx_buf, len - 1);
 118   1        bt_uart_tx_buf[len - 1] = check_sum;
 119   1        //
 120   1        bt_uart_write_data((unsigned char *)bt_uart_tx_buf, len);
 121   1      }
 122          /*****************************************************************************
 123          函数名称 : heat_beat_check
 124          功能描述 : 心跳包检测
 125          输入参数 : 无
 126          返回参数 : 无
 127          *****************************************************************************/
 128          static void heat_beat_check(void)
 129          {
 130   1        unsigned char length = 0;
 131   1        static unsigned char mcu_reset_state = FALSE;
 132   1        
 133   1        if(FALSE == mcu_reset_state)
 134   1        {
 135   2          length = set_bt_uart_byte(length,FALSE);
 136   2          mcu_reset_state = TRUE;
 137   2        }
 138   1        else
 139   1        {
 140   2          length = set_bt_uart_byte(length,TRUE);
 141   2        }
 142   1        
 143   1        bt_uart_write_frame(HEAT_BEAT_CMD, length);
 144   1      }
 145          /*****************************************************************************
 146          函数名称  : product_info_update
 147          功能描述  : 产品信息上传
 148          输入参数 : 无
 149          返回参数 : 无
 150          *****************************************************************************/
 151          static void product_info_update(void)
 152          {
 153   1        unsigned char length = 0;
 154   1        
 155   1        length = set_bt_uart_buffer(length,(unsigned char *)PRODUCT_KEY,my_strlen((unsigned char *)PRODUCT_KEY))
             -;
 156   1        length = set_bt_uart_buffer(length,(unsigned char *)MCU_VER,my_strlen((unsigned char *)MCU_VER));
 157   1        
 158   1        bt_uart_write_frame(PRODUCT_INFO_CMD, length);
 159   1      }
 160          /*****************************************************************************
 161          函数名称 : get_mcu_bt_mode
 162          功能描述 : 查询mcu和bt的工作模式
 163          输入参数 : 无
 164          返回参数 : 无
 165          *****************************************************************************/
 166          static void get_mcu_bt_mode(void)
 167          {
 168   1        unsigned char length = 0;
 169   1        
 170   1      #ifdef BT_CONTROL_SELF_MODE                                   //模块自处理
                length = set_bt_uart_byte(length, BT_STATE_KEY);
                length = set_bt_uart_byte(length, BT_RESERT_KEY);
              #else                                                           
 174   1        //无需处理数据
 175   1      #endif
 176   1        
 177   1        bt_uart_write_frame(WORK_MODE_CMD, length);
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 4   

 178   1      }
 179          /*****************************************************************************
 180          函数名称 : get_update_dpid_index
 181          功能描述 : 或许制定DPID在数组中的序号
 182          输入参数 : dpid:dpid
 183          返回参数 : index:dp序号
 184          *****************************************************************************/
 185          static unsigned char get_dowmload_dpid_index(unsigned char dpid)
 186          {
 187   1        unsigned char index;
 188   1        unsigned char total = get_download_cmd_total();
 189   1        
 190   1        for(index = 0; index < total; index ++)
 191   1        {
 192   2          if(download_cmd[index].dp_id == dpid)
 193   2          {
 194   3            break;
 195   3          }
 196   2        }
 197   1        
 198   1        return index;
 199   1      }
 200          /*****************************************************************************
 201          函数名称 : data_point_handle
 202          功能描述 : 下发数据处理
 203          输入参数 : value:下发数据源指针
 204          返回参数 : ret:返回数据处理结果
 205          *****************************************************************************/
 206          static unsigned char data_point_handle(const unsigned char value[])
 207          {
 208   1        unsigned char dp_id,index;
 209   1        unsigned char dp_type;
 210   1        unsigned char ret;
 211   1        unsigned short dp_len;
 212   1        
 213   1        dp_id = value[0];
 214   1        dp_type = value[1];
 215   1        dp_len = value[2] * 0x100;
 216   1        dp_len += value[3];
 217   1        
 218   1        index = get_dowmload_dpid_index(dp_id);
 219   1      
 220   1        if(dp_type != download_cmd[index].dp_type)
 221   1        {
 222   2          //错误提示
 223   2          return FALSE;
 224   2        }
 225   1        else
 226   1        {
 227   2          ret = dp_download_handle(dp_id,value + 4,dp_len);
 228   2        }
 229   1        
 230   1        return ret;
 231   1      }
 232          /*****************************************************************************
 233          函数名称 : data_handle
 234          功能描述 : 数据帧处理
 235          输入参数 : offset:数据起始位
 236          返回参数 : 无
 237          *****************************************************************************/
 238          void data_handle(unsigned short offset)
 239          {
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 5   

 240   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
                unsigned char *firmware_addr;
                static unsigned long firm_length;                                             //MCU升级文件长度
                static unsigned char firm_update_flag;                                        //MCU升级标志
                unsigned long dp_len;
              #else
 246   1        unsigned short dp_len;
 247   1      #endif
 248   1        
 249   1        unsigned char ret;
 250   1        unsigned short i,total_len;
 251   1        unsigned char cmd_type = bt_uart_rx_buf[offset + FRAME_TYPE];
 252   1        
 253   1        switch(cmd_type)
 254   1        {
 255   2        case HEAT_BEAT_CMD:                                   //心跳包
 256   2          heat_beat_check();
 257   2          break;
 258   2          
 259   2        case PRODUCT_INFO_CMD:                                //产品信息
 260   2          product_info_update();
 261   2          break;
 262   2          
 263   2        case WORK_MODE_CMD:                                   //查询MCU设定的模块工作模式
 264   2          get_mcu_bt_mode();
 265   2          break;
 266   2          
 267   2      #ifndef BT_CONTROL_SELF_MODE
 268   2        case BT_STATE_CMD:                                  //bt工作状态  
 269   2          bt_work_state = bt_uart_rx_buf[offset + DATA_START];
 270   2          bt_uart_write_frame(BT_STATE_CMD,0);
 271   2          break;
 272   2      
 273   2        case BT_RESET_CMD:                                  //重置bt(bt返回成功)
 274   2          reset_bt_flag = RESET_BT_SUCCESS;
 275   2          break;
 276   2      #endif
 277   2          
 278   2        case DATA_QUERT_CMD:                                  //命令下发
 279   2          total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
 280   2          total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
 281   2          
 282   2          for(i = 0;i < total_len;)
 283   2          {
 284   3            dp_len = bt_uart_rx_buf[offset + DATA_START + i + 2] * 0x100;
 285   3            dp_len += bt_uart_rx_buf[offset + DATA_START + i + 3];
 286   3            //
 287   3            ret = data_point_handle((unsigned char *)bt_uart_rx_buf + offset + DATA_START + i);
 288   3            
 289   3            if(SUCCESS == ret)
 290   3            {
 291   4              //成功提示
 292   4            }
 293   3            else
 294   3            {
 295   4              //错误提示
 296   4            }
 297   3            
 298   3            i += (dp_len + 4);
 299   3          }
 300   2          
 301   2          break;
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 6   

 302   2          
 303   2        case STATE_QUERY_CMD:                                 //状态查询
 304   2          all_data_update();                               
 305   2          break;
 306   2          
 307   2      #ifdef SUPPORT_MCU_FIRM_UPDATE
                case UPDATE_START_CMD:                                //升级开始
                  firm_length = bt_uart_rx_buf[offset + DATA_START];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 1];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 2];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 3];
                  //
                  bt_uart_write_frame(UPDATE_START_CMD,0);
                  firm_update_flag = UPDATE_START_CMD;
                   break;
                  
                case UPDATE_TRANS_CMD:                                //升级传输
                  if(firm_update_flag == UPDATE_START_CMD)
                  {
                    //停止一切数据上报
                    stop_update_flag = ENABLE;                                                 
                    
                    total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
                    total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
                    
                    dp_len = bt_uart_rx_buf[offset + DATA_START];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 1];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 2];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 3];
                    
                    firmware_addr = bt_uart_rx_buf + offset + DATA_START + 4;
                    if((total_len == 4) && (dp_len == firm_length))
                    {
                      //最后一包
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
                      
                      firm_update_flag = 0;
                    }
                    else if((total_len - 4) <= FIRM_UPDATA_SIZE)
                    {
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
                    }
                    else
                    {
                      firm_update_flag = 0;
                      ret = ERROR;
                    }
                    
                    if(ret == SUCCESS)
                    {
                      bt_uart_write_frame(UPDATE_TRANS_CMD,0);
                    }
                    //恢复一切数据上报
                    stop_update_flag = DISABLE;    
                  }
                  break;
C51 COMPILER V8.02   SYSTEM                                                                10/06/2020 17:42:47 PAGE 7   

              #endif      
 365   2      
 366   2        default:
 367   2          break;
 368   2        }
 369   1      }
 370          /*****************************************************************************
 371          函数名称 : get_queue_total_data
 372          功能描述 : 读取队列内数据
 373          输入参数 : 无
 374          返回参数 : 无
 375          *****************************************************************************/
 376          unsigned char get_queue_total_data(void)
 377          {
 378   1        if(queue_in != queue_out)
 379   1          return 1;
 380   1        else
 381   1          return 0;
 382   1      }
 383          /*****************************************************************************
 384          函数名称 : Queue_Read_Byte
 385          功能描述 : 读取队列1字节数据
 386          输入参数 : 无
 387          返回参数 : 无
 388          *****************************************************************************/
 389          unsigned char Queue_Read_Byte(void)
 390          {
 391   1        unsigned char value;
 392   1        
 393   1        if(queue_out != queue_in)
 394   1        {
 395   2          //有数据
 396   2          if(queue_out >= (unsigned char *)(bt_queue_buf + sizeof(bt_queue_buf)))
 397   2          {
 398   3            //数据已经到末尾
 399   3            queue_out = (unsigned char *)(bt_queue_buf);
 400   3          }
 401   2          
 402   2          value = *queue_out ++;   
 403   2        }
 404   1        
 405   1        return value;
 406   1      }
 407          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1004    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     88      40
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

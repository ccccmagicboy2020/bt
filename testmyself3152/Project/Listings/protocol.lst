C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\protocol.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\protocol.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /****************************************Copyright (c)*************************
   2          **                               ç‰ˆæƒæ‰€æœ‰ (C), 2015-2017, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                                 http://www.tuya.com
   5          **
   6          **--------------æ–‡ä»¶ä¿¡æ¯-------------------------------------------------------
   7          **æ–‡   ä»¶   å: protocol.c
   8          **æ        è¿°: ä¸‹å‘/ä¸ŠæŠ¥æ•°æ®å¤„ç†å‡½æ•°
   9          **ä½¿ ç”¨ è¯´ æ˜ :
  10          
  11                            *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  12          
  13          ** 1ã€ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  14          ** 2ã€DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  15          ** 3ã€å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•°åè¯·å
             -ˆ é™¤è¯¥#err
  16          **
  17          **--------------å½“å‰ç‰ˆæœ¬ä¿®è®¢---------------------------------------------------
  18          ** ç‰ˆ  æœ¬: v1.0
  19          ** æ—¥ã€€æœŸ: 2017å¹´5æœˆ3æ—¥
  20          ** æã€€è¿°: 1:åˆ›å»ºæ¶‚é¸¦bluetoothå¯¹æ¥MCU_SDK
  21          **
  22          **-----------------------------------------------------------------------------
  23          ******************************************************************************/
  24          //#include "include.h"
  25          
  26          #include "bluetooth.h"
  27          #include "string.h"
  28          #include <stdio.h>
  29            
  30          
  31          extern u8 xdata switchcnt;      //å¤ä½æ¨¡å—ç‚¹å‡»æ¬¡æ•°è®¡æ•°
  32          extern u8 xdata reset_bt_bn;    //å¤ä½æ¨¡å—çš„å…¨å±€å˜é‡
  33          extern u8 xdata SWITCHflag2;   //å¼€å…³ç¯çš„å˜é‡
  34          extern u8 xdata SWITCHfXBR;    //å¼€å…³é›·è¾¾çš„å˜é‡
  35          extern u8 xdata lightvalue;    //ç¯äº®å€¼
  36          extern u8 xdata XRBoffbrightvalue;  //å…³é›·è¾¾åçš„ç¯äº®å€¼
  37          extern ulong xdata TH;          //é›·è¾¾æ„Ÿåº”åå·®é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§ä»£è¡¨è¶Šä¸çµæ•
  38          extern u8 xdata LIGHT_TH;       //æ„Ÿå…‰é˜ˆå€¼
  39          extern u16 xdata DELAY_NUM;     //æ„Ÿåº”å»¶æ—¶ï¼Œå•ä½ä¸ºç§’
  40          extern u8 xdata lowlightDELAY_NUM;      //å…³ç¯å»¶æ—¶ï¼Œå•ä½ä¸ºåˆ†é’Ÿ
  41          extern u8 xdata light_ad;               //é‡‡åˆ°çš„å…‰æ„Ÿçš„ç¬æ—¶å€¼
  42          u8 xdata cdsvalue = 0;              //æ„Ÿå…‰é€‰æ‹©å€¼
  43          ulong xdata sensing_th = 0;     //é›·è¾¾æ„Ÿåº”é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§è¶Šçµæ•
  44          
  45          //const char xdata led_bn_on[]={"led on"};
  46          //const char xdata led_bn_off[]={"led off"};
  47          //const char xdata radar_bn_on[]={"radar on"};
  48          //const char xdata radar_bn_off[]={"radar off"};
  49          
  50          unsigned char DPID_SWITCH_LED2count = 0;
  51          unsigned char DPID_SWITCH_XBRcount = 0;
  52          unsigned char DPID_BRIGHT_VALUEcount = 0;
  53          unsigned char DPID_CDScount = 0;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 2   

  54          unsigned char DPID_PIR_DELAYcount = 0;
  55          unsigned char DPID_STANDBY_TIMEcount = 0;
  56          unsigned char DPID_SENSING_RADIUScount = 0;
  57          
  58          extern u16 idata groupaddr[8];
  59          
  60          //extern TYPE_BUFFER_S FlashBuffer;
  61          void send_data(u8 d);
  62          void reset_bt_module(void);
  63          unsigned char PWM3init(unsigned char ab);
  64          void savevar(void);
  65          void Flash_EraseBlock(unsigned int fui_Address);//flashæ‰‡åŒºæ“¦é™¤
  66          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);//flashå†™å…¥
  67          void Delay_us_1(uint q1);
  68          
  69          void reset_bt_module(void)
  70          {
  71   1        send_data(0x55);
  72   1        send_data(0xAA);
  73   1        send_data(0x00);
  74   1        send_data(0x04);
  75   1        send_data(0x00);
  76   1        send_data(0x00);
  77   1        send_data(0x03);
  78   1      }
  79          
  80          /******************************************************************************
  81                                          ç§»æ¤é¡»çŸ¥:
  82          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„bt_uart_service()å‡½æ•°
  83          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  84          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  85          ******************************************************************************/
  86          
  87                   
  88          /******************************************************************************
  89                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  90          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°btç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "bt.h"
  91          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„bt_protocol_init()å‡½æ•°
  92          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  93          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  94          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„bt_uart_service()å‡½æ•°
  95          ******************************************************************************/
  96          
  97          /******************************************************************************
  98                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  99                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
 100          ******************************************************************************/
 101          const DOWNLOAD_CMD_S xdata download_cmd[] =
 102          {
 103            {DPID_SWITCH_LED, DP_TYPE_BOOL},
 104            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
 105            {DPID_CDS, DP_TYPE_ENUM},
 106            {DPID_PIR_DELAY, DP_TYPE_VALUE},
 107            {DPID_SWITCH_XBR, DP_TYPE_BOOL},
 108            {DPID_STANDBY_TIME, DP_TYPE_VALUE},
 109            {DPID_SENSE_STRESS, DP_TYPE_VALUE},
 110            {DPID_ADDR, DP_TYPE_VALUE},
 111            {DPID_ADDREND, DP_TYPE_VALUE},
 112            {DPID_GROUP, DP_TYPE_VALUE},
 113            {DPID_DEBUG, DP_TYPE_STRING},
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 3   

 114            {DPID_TEST_BN0, DP_TYPE_BOOL},
 115            {DPID_TEST_BN1, DP_TYPE_BOOL},
 116            {DPID_TEST_BN2, DP_TYPE_BOOL},
 117            {DPID_SWITCH_LED2, DP_TYPE_BOOL},
 118          };
 119          
 120          
 121          
 122          
 123          /******************************************************************************
 124                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 125          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
 126          ******************************************************************************/
 127          
 128          /*****************************************************************************
 129          å‡½æ•°åç§° : uart_transmit_output
 130          åŠŸèƒ½æè¿° : å‘æ•°æ®å¤„ç†
 131          è¾“å…¥å‚æ•° : value:ä¸²å£æ”¶åˆ°å­—èŠ‚æ•°æ®
 132          è¿”å›å‚æ•° : æ— 
 133          ä½¿ç”¨è¯´æ˜ : è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²
             -å£å‘é€å‡½æ•°
 134          *****************************************************************************/
 135          void uart_transmit_output(unsigned char value)
 136          {
 137   1      // #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 138   1          send_data(value);
 139   1        
 140   1      /*
 141   1        //ç¤ºä¾‹:
 142   1        extern void Uart_PutChar(unsigned char value);
 143   1        Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 144   1      */  
 145   1      }
 146          /******************************************************************************
 147                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 148          1:APPä¸‹å‘æ•°æ®å¤„ç†
 149          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 150          ******************************************************************************/
 151          
 152          /******************************************************************************
 153                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 154          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 155            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 156            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 157            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 158          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 159          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 160          ******************************************************************************/
 161          
 162          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 163          
 164          /*****************************************************************************
 165          å‡½æ•°åç§° : all_data_update
 166          åŠŸèƒ½æè¿° : ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 167          è¾“å…¥å‚æ•° : æ— 
 168          è¿”å›å‚æ•° : æ— 
 169          ä½¿ç”¨è¯´æ˜ : æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨;
 170                     MCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½;åŒ…æ‹¬åªä¸ŠæŠ¥å’Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 171          *****************************************************************************/
 172          void all_data_update(void)
 173          {
 174   1          u8 light;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 4   

 175   1          u8 radius;
 176   1        //#error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 177   1        //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸ŠæŠ¥
             -å‡½æ•°
 178   1        
 179   1          mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn); //å¤ä½æ¨¡å—
 180   1          mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2); //ç¯çš„å¼€å…³
 181   1          mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 182   1      
 183   1        if(LIGHT_TH==255)
 184   1          light=0;
 185   1        else if(LIGHT_TH==200)
 186   1          light=2;
 187   1        else if(LIGHT_TH==40)
 188   1          light=3;    
 189   1        else if(LIGHT_TH==20)
 190   1          light=4;
 191   1        else //if(LIGHT_TH==200)
 192   1          light=5;
 193   1      
 194   1          mcu_dp_enum_update(DPID_CDS, light); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 195   1          mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 196   1          mcu_dp_bool_update(DPID_SWITCH_XBR, SWITCHfXBR); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 197   1          mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 198   1      
 199   1        radius=TH/10000;
 200   1        radius=50-radius;
 201   1      
 202   1          mcu_dp_value_update(DPID_SENSE_STRESS, radius); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 203   1      
 204   1          mcu_dp_value_update(DPID_ADDR, 10); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 205   1          mcu_dp_value_update(DPID_ADDREND, 11); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 206   1          mcu_dp_value_update(DPID_GROUP, 12); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 207   1      
 208   1      
 209   1          mcu_dp_string_update(DPID_DEBUG, "1012", 4); //STRINGå‹æ•°æ®ä¸ŠæŠ¥;
 210   1      
 211   1      
 212   1          //mcu_dp_bool_update(DPID_TEST_BN0,å½“å‰æµ‹è¯•å¼€å…³0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 213   1          //mcu_dp_bool_update(DPID_TEST_BN1,å½“å‰æµ‹è¯•å¼€å…³1); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 214   1          //mcu_dp_bool_update(DPID_TEST_BN2,å½“å‰æµ‹è¯•å¼€å…³2); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 215   1      
 216   1      
 217   1      
 218   1      }
 219          
 220          
 221          /******************************************************************************
 222                                          WARNING!!!    
 223                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 224          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 225          ******************************************************************************/
 226          
 227          /*****************************************************************************
 228          å‡½æ•°åç§° : dp_download_switch_led_handle
 229          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LEDçš„å¤„ç†å‡½æ•°
 230          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 231                  : length:æ•°æ®é•¿åº¦
 232          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 233          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 234          *****************************************************************************/
 235          static unsigned char dp_download_switch_led_handle(const unsigned char value[], unsigned short length)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 5   

 236          {
 237   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 238   1          unsigned char ret;
 239   1          //0:å…³/1:å¼€
 240   1          unsigned char switch_led;
 241   1          
 242   1          switch_led = mcu_get_dp_download_bool(value,length);
 243   1      
 244   1          reset_bt_bn = switch_led;
 245   1        
 246   1          
 247   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 248   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn);
 249   1          if(ret == SUCCESS)
 250   1              return SUCCESS;
 251   1          else
 252   1              return ERROR;
 253   1      }
 254          /*****************************************************************************
 255          å‡½æ•°åç§° : dp_download_bright_value_handle
 256          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 257          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 258                  : length:æ•°æ®é•¿åº¦
 259          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 260          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 261          *****************************************************************************/
 262          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 263          {
 264   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 265   1          unsigned char ret;
 266   1          unsigned long bright_value;
 267   1          unsigned char i;
 268   1          
 269   1          bright_value = mcu_get_dp_download_value(value,length);
 270   1        
 271   1        DPID_BRIGHT_VALUEcount++;
 272   1        if(bright_value==lightvalue)
 273   1        {
 274   2          //
 275   2        }
 276   1        else
 277   1        {
 278   2          DPID_BRIGHT_VALUEcount=0;
 279   2          for(i=0;i<8;i++)
 280   2          {
 281   3            if(groupaddr[i] != 0)
 282   3            {
 283   4              mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 284   4            }
 285   3          }
 286   2        } 
 287   1        
 288   1          lightvalue = bright_value;
 289   1      
 290   1        if(SWITCHfXBR==0)
 291   1        {
 292   2          XRBoffbrightvalue = bright_value;
 293   2        }
 294   1        
 295   1        savevar();
 296   1          
 297   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 6   

 298   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue);
 299   1      
 300   1          if(ret == SUCCESS)
 301   1              return SUCCESS;
 302   1          else
 303   1              return ERROR;
 304   1      }
 305          /*****************************************************************************
 306          å‡½æ•°åç§° : dp_download_cds_handle
 307          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_CDSçš„å¤„ç†å‡½æ•°
 308          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 309                  : length:æ•°æ®é•¿åº¦
 310          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 311          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 312          *****************************************************************************/
 313          static unsigned char dp_download_cds_handle(const unsigned char value[], unsigned short length)
 314          {
 315   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 316   1          unsigned char ret;
 317   1          unsigned char cds;
 318   1          unsigned char i;
 319   1          
 320   1          cds = mcu_get_dp_download_enum(value,length);
 321   1        
 322   1        DPID_CDScount++;
 323   1        if(cds==cdsvalue)
 324   1        {
 325   2          if(DPID_CDScount<2)
 326   2          {
 327   3            for(i=0;i<8;i++)
 328   3            {
 329   4              if(groupaddr[i] != 0)
 330   4              {
 331   5                mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 332   5              }
 333   4            }
 334   3          }
 335   2          if((cds==5)&&(light_ad!=LIGHT_TH))
 336   2          {
 337   3            DPID_CDScount=0;
 338   3          }
 339   2        }
 340   1        else
 341   1        {
 342   2          DPID_CDScount=0;
 343   2          for(i=0;i<8;i++)
 344   2          {
 345   3            if(groupaddr[i] != 0)
 346   3            {
 347   4              mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 348   4            }
 349   3          }
 350   2        } 
 351   1        
 352   1          switch(cds) {
 353   2              case 0:   //2000LUS
 354   2            LIGHT_TH=255;//cds*4;
 355   2              break;
 356   2              
 357   2              case 1:   //300LUX
 358   2            LIGHT_TH=255;//cds*4;
 359   2              break;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 7   

 360   2              
 361   2              case 2:   //50LUX
 362   2            LIGHT_TH=200;
 363   2              break;
 364   2              
 365   2              case 3: //10LUX
 366   2            LIGHT_TH=40;
 367   2              break;
 368   2              
 369   2              case 4: //5LUX
 370   2            LIGHT_TH=20;
 371   2              break;
 372   2              
 373   2          case 5:
 374   2            LIGHT_TH = light_ad;
 375   2          break;
 376   2              
 377   2              default:
 378   2          
 379   2              break;
 380   2          }
 381   1      
 382   1          cdsvalue = cds;
 383   1      
 384   1          savevar();
 385   1          //sprintf(temp_str, "%3d", LIGHT_TH);
 386   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));
 387   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 388   1          ret = mcu_dp_enum_update(DPID_CDS, cdsvalue);
 389   1          if(ret == SUCCESS)
 390   1              return SUCCESS;
 391   1          else
 392   1              return ERROR;
 393   1      }
 394          /*****************************************************************************
 395          å‡½æ•°åç§° : dp_download_pir_delay_handle
 396          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PIR_DELAYçš„å¤„ç†å‡½æ•°
 397          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 398                  : length:æ•°æ®é•¿åº¦
 399          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 400          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 401          *****************************************************************************/
 402          static unsigned char dp_download_pir_delay_handle(const unsigned char value[], unsigned short length)
 403          {
 404   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 405   1          unsigned char ret;
 406   1          unsigned long pir_delay;
 407   1          unsigned char i;
 408   1          
 409   1          pir_delay = mcu_get_dp_download_value(value,length);
 410   1          /*
 411   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 412   1          */
 413   1        
 414   1        DPID_PIR_DELAYcount++;
 415   1        if(pir_delay==DELAY_NUM)
 416   1        {
 417   2          if(DPID_PIR_DELAYcount<2)
 418   2          {
 419   3            for(i=0;i<8;i++)
 420   3            {
 421   4              if(groupaddr[i] != 0)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 8   

 422   4              {
 423   5                mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 424   5              }
 425   4            }
 426   3          }
 427   2        
 428   2        }
 429   1        else
 430   1        {
 431   2          DPID_PIR_DELAYcount=0;
 432   2          for(i=0;i<8;i++)
 433   2          {
 434   3            if(groupaddr[i] != 0)
 435   3            {
 436   4              mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 437   4            }
 438   3          }
 439   2        }
 440   1        
 441   1          DELAY_NUM = pir_delay;
 442   1        savevar();
 443   1          
 444   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 445   1          ret = mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM);
 446   1          if(ret == SUCCESS)
 447   1              return SUCCESS;
 448   1          else
 449   1              return ERROR;
 450   1      }
 451          /*****************************************************************************
 452          å‡½æ•°åç§° : dp_download_switch_xbr_handle
 453          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_XBRçš„å¤„ç†å‡½æ•°
 454          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 455                  : length:æ•°æ®é•¿åº¦
 456          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 457          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 458          *****************************************************************************/
 459          static unsigned char dp_download_switch_xbr_handle(const unsigned char value[], unsigned short length)
 460          {
 461   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 462   1          unsigned char ret;
 463   1          //0:å…³/1:å¼€
 464   1          unsigned char switch_xbr;
 465   1          unsigned char i;
 466   1          
 467   1          switch_xbr = mcu_get_dp_download_bool(value,length);
 468   1        
 469   1        DPID_SWITCH_XBRcount++;
 470   1        if(switch_xbr==SWITCHfXBR)
 471   1        {
 472   2          if(DPID_SWITCH_XBRcount<2)
 473   2          {
 474   3            for(i=0;i<8;i++)
 475   3            {
 476   4              if(groupaddr[i] != 0)
 477   4              {
 478   5                mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 479   5              }
 480   4            }
 481   3          }
 482   2        
 483   2        }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 9   

 484   1        else
 485   1        {
 486   2          DPID_SWITCH_XBRcount=0;
 487   2          for(i=0;i<8;i++)
 488   2          {
 489   3            if(groupaddr[i] != 0)
 490   3            {
 491   4              mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 492   4            }
 493   3          }
 494   2        
 495   2        }
 496   1        
 497   1          if(switch_xbr == 0) {
 498   2              //å¼€å…³å…³
 499   2              SWITCHfXBR = 0;
 500   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_off, strlen(radar_bn_off));
 501   2          }else {
 502   2              //å¼€å…³å¼€
 503   2              SWITCHfXBR = 1;
 504   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_on, strlen(radar_bn_on));
 505   2          }
 506   1        
 507   1          savevar();
 508   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 509   1          ret = mcu_dp_bool_update(DPID_SWITCH_XBR,SWITCHfXBR);
 510   1          if(ret == SUCCESS)
 511   1              return SUCCESS;
 512   1          else
 513   1              return ERROR;
 514   1      }
 515          /*****************************************************************************
 516          å‡½æ•°åç§° : dp_download_standby_time_handle
 517          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_STANDBY_TIMEçš„å¤„ç†å‡½æ•°
 518          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 519                  : length:æ•°æ®é•¿åº¦
 520          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 521          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 522          *****************************************************************************/
 523          static unsigned char dp_download_standby_time_handle(const unsigned char value[], unsigned short length)
 524          {
 525   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 526   1          unsigned char ret;
 527   1          unsigned long standby_time;
 528   1          unsigned char i;
 529   1          
 530   1          standby_time = mcu_get_dp_download_value(value,length);
 531   1          /*
 532   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 533   1          
 534   1          */
 535   1        DPID_STANDBY_TIMEcount++;
 536   1        if(standby_time==lowlightDELAY_NUM)
 537   1        {
 538   2          if(DPID_STANDBY_TIMEcount<2)
 539   2          {
 540   3            for(i=0;i<8;i++)
 541   3            {
 542   4              if(groupaddr[i] != 0)
 543   4              {
 544   5                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 545   5              }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 10  

 546   4            }
 547   3          }
 548   2        
 549   2        }
 550   1        else
 551   1        {
 552   2          DPID_STANDBY_TIMEcount=0;
 553   2          for(i=0;i<8;i++)
 554   2            {
 555   3              if(groupaddr[i] != 0)
 556   3              {
 557   4                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 558   4              }
 559   3            }
 560   2        
 561   2        }
 562   1        
 563   1          lowlightDELAY_NUM=standby_time;
 564   1          
 565   1          savevar();
 566   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 567   1          ret = mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM);
 568   1          if(ret == SUCCESS)
 569   1              return SUCCESS;
 570   1          else
 571   1              return ERROR;
 572   1      }
 573          /*****************************************************************************
 574          å‡½æ•°åç§° : dp_download_sense_stress_handle
 575          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SENSE_STRESSçš„å¤„ç†å‡½æ•°
 576          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 577                  : length:æ•°æ®é•¿åº¦
 578          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 579          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 580          *****************************************************************************/
 581          static unsigned char dp_download_sense_stress_handle(const unsigned char value[], unsigned short length)
 582          {
 583   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 584   1          unsigned char ret;
 585   1          unsigned long sense_stress;
 586   1          unsigned char i;
 587   1          
 588   1          sense_stress = mcu_get_dp_download_value(value,length);
 589   1          /*
 590   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 591   1          
 592   1          */
 593   1        DPID_SENSING_RADIUScount++;
 594   1        if(sense_stress==sensing_th)
 595   1        {
 596   2          if(DPID_SENSING_RADIUScount<2)
 597   2          {
 598   3            for(i=0;i<8;i++)
 599   3            {
 600   4              if(groupaddr[i] != 0)
 601   4              {
 602   5                mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 603   5              }
 604   4            }
 605   3          }
 606   2        }
 607   1        else
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 11  

 608   1        {
 609   2          DPID_SENSING_RADIUScount=0;
 610   2          for(i=0;i<8;i++)
 611   2          {
 612   3            if(groupaddr[i] != 0)
 613   3            {
 614   4              mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 615   4            }
 616   3          }
 617   2        } 
 618   1        
 619   1        sensing_th = sense_stress;
 620   1        TH=(50-sense_stress)*10000;
 621   1          
 622   1        savevar();
 623   1          
 624   1          //sprintf(temp_str, "%6d", TH);
 625   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));    
 626   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 627   1          ret = mcu_dp_value_update(DPID_SENSE_STRESS, sensing_th);
 628   1          if(ret == SUCCESS)
 629   1              return SUCCESS;
 630   1          else
 631   1              return ERROR;
 632   1      }
 633          /*****************************************************************************
 634          å‡½æ•°åç§° : dp_download_addr_handle
 635          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_ADDRçš„å¤„ç†å‡½æ•°
 636          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 637                  : length:æ•°æ®é•¿åº¦
 638          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 639          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 640          *****************************************************************************/
 641          static unsigned char dp_download_addr_handle(const unsigned char value[], unsigned short length)
 642          {
 643   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 644   1          unsigned char ret;
 645   1          unsigned long addr;
 646   1          
 647   1          addr = mcu_get_dp_download_value(value,length);
 648   1          /*
 649   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 650   1          
 651   1          */
 652   1          
 653   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 654   1          ret = mcu_dp_value_update(DPID_ADDR,addr);
 655   1          if(ret == SUCCESS)
 656   1              return SUCCESS;
 657   1          else
 658   1              return ERROR;
 659   1      }
 660          /*****************************************************************************
 661          å‡½æ•°åç§° : dp_download_addrend_handle
 662          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_ADDRENDçš„å¤„ç†å‡½æ•°
 663          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 664                  : length:æ•°æ®é•¿åº¦
 665          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 666          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 667          *****************************************************************************/
 668          static unsigned char dp_download_addrend_handle(const unsigned char value[], unsigned short length)
 669          {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 12  

 670   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 671   1          unsigned char ret;
 672   1          unsigned long addrend;
 673   1          
 674   1          addrend = mcu_get_dp_download_value(value,length);
 675   1          /*
 676   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 677   1          
 678   1          */
 679   1          
 680   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 681   1          ret = mcu_dp_value_update(DPID_ADDREND,addrend);
 682   1          if(ret == SUCCESS)
 683   1              return SUCCESS;
 684   1          else
 685   1              return ERROR;
 686   1      }
 687          /*****************************************************************************
 688          å‡½æ•°åç§° : dp_download_group_handle
 689          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_GROUPçš„å¤„ç†å‡½æ•°
 690          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 691                  : length:æ•°æ®é•¿åº¦
 692          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 693          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 694          *****************************************************************************/
 695          static unsigned char dp_download_group_handle(const unsigned char value[], unsigned short length)
 696          {
 697   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 698   1          unsigned char ret;
 699   1          unsigned long group;
 700   1          
 701   1          group = mcu_get_dp_download_value(value,length);
 702   1          /*
 703   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 704   1          
 705   1          */
 706   1          
 707   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 708   1          ret = mcu_dp_value_update(DPID_GROUP,group);
 709   1          if(ret == SUCCESS)
 710   1              return SUCCESS;
 711   1          else
 712   1              return ERROR;
 713   1      }
 714          /*****************************************************************************
 715          å‡½æ•°åç§° : dp_download_test_bn0_handle
 716          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN0çš„å¤„ç†å‡½æ•°
 717          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 718                  : length:æ•°æ®é•¿åº¦
 719          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 720          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 721          *****************************************************************************/
 722          static unsigned char dp_download_test_bn0_handle(const unsigned char value[], unsigned short length)
 723          {
 724   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 725   1          unsigned char ret;
 726   1          //0:å…³/1:å¼€
 727   1          unsigned char test_bn0;
 728   1          
 729   1          test_bn0 = mcu_get_dp_download_bool(value,length);
 730   1          if(test_bn0 == 0) {
 731   2              //å¼€å…³å…³
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 13  

 732   2          }else {
 733   2              //å¼€å…³å¼€
 734   2          }
 735   1        
 736   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 737   1          ret = mcu_dp_bool_update(DPID_TEST_BN0,test_bn0);
 738   1          if(ret == SUCCESS)
 739   1              return SUCCESS;
 740   1          else
 741   1              return ERROR;
 742   1      }
 743          /*****************************************************************************
 744          å‡½æ•°åç§° : dp_download_test_bn1_handle
 745          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN1çš„å¤„ç†å‡½æ•°
 746          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 747                  : length:æ•°æ®é•¿åº¦
 748          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 749          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 750          *****************************************************************************/
 751          static unsigned char dp_download_test_bn1_handle(const unsigned char value[], unsigned short length)
 752          {
 753   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 754   1          unsigned char ret;
 755   1          //0:å…³/1:å¼€
 756   1          unsigned char test_bn1;
 757   1          
 758   1          test_bn1 = mcu_get_dp_download_bool(value,length);
 759   1          if(test_bn1 == 0) {
 760   2              //å¼€å…³å…³
 761   2          }else {
 762   2              //å¼€å…³å¼€
 763   2          }
 764   1        
 765   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 766   1          ret = mcu_dp_bool_update(DPID_TEST_BN1,test_bn1);
 767   1          if(ret == SUCCESS)
 768   1              return SUCCESS;
 769   1          else
 770   1              return ERROR;
 771   1      }
 772          /*****************************************************************************
 773          å‡½æ•°åç§° : dp_download_test_bn2_handle
 774          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN2çš„å¤„ç†å‡½æ•°
 775          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 776                  : length:æ•°æ®é•¿åº¦
 777          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 778          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 779          *****************************************************************************/
 780          static unsigned char dp_download_test_bn2_handle(const unsigned char value[], unsigned short length)
 781          {
 782   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 783   1          unsigned char ret;
 784   1          //0:å…³/1:å¼€
 785   1          unsigned char test_bn2;
 786   1          
 787   1          test_bn2 = mcu_get_dp_download_bool(value,length);
 788   1          if(test_bn2 == 0) {
 789   2              //å¼€å…³å…³
 790   2          }else {
 791   2              //å¼€å…³å¼€
 792   2          }
 793   1        
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 14  

 794   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 795   1          ret = mcu_dp_bool_update(DPID_TEST_BN2,test_bn2);
 796   1          if(ret == SUCCESS)
 797   1              return SUCCESS;
 798   1          else
 799   1              return ERROR;
 800   1      }
 801          /*****************************************************************************
 802          å‡½æ•°åç§° : dp_download_switch_led2_handle
 803          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LED2çš„å¤„ç†å‡½æ•°
 804          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 805                  : length:æ•°æ®é•¿åº¦
 806          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 807          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 808          *****************************************************************************/
 809          static unsigned char dp_download_switch_led2_handle(const unsigned char value[], unsigned short length)
 810          {
 811   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 812   1          unsigned char ret;
 813   1          //0:å…³/1:å¼€
 814   1          unsigned char switch_led2;
 815   1          unsigned char i;
 816   1          
 817   1          switch_led2 = mcu_get_dp_download_bool(value,length);
 818   1      
 819   1          DPID_SWITCH_LED2count++;
 820   1          if(switch_led2==SWITCHflag2)
 821   1          {
 822   2            if(DPID_SWITCH_LED2count<2)
 823   2            {
 824   3              for(i=0;i<8;i++)
 825   3              {
 826   4                if(groupaddr[i] != 0)
 827   4                {
 828   5                  mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 829   5                }
 830   4              }
 831   3            }
 832   2      
 833   2          }
 834   1          else
 835   1          {
 836   2            DPID_SWITCH_LED2count=0;
 837   2            for(i=0;i<8;i++)
 838   2            {
 839   3              if(groupaddr[i] != 0)
 840   3              {
 841   4                mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 842   4              }
 843   3            }   
 844   2      
 845   2          }
 846   1      
 847   1          if(switch_led2 == 0) {
 848   2              //ç¯å¼€å…³å…³
 849   2              //mcu_dp_string_update(DPID_DEBUG, led_bn_off, strlen(led_bn_off));
 850   2          if(SWITCHfXBR==1)
 851   2          {
 852   3            PWM3init(0);
 853   3          }
 854   2              SWITCHflag2=0;
 855   2          }else {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 15  

 856   2              //ç¯å¼€å…³å¼€
 857   2              //mcu_dp_string_update(DPID_DEBUG, led_bn_on, strlen(led_bn_on));
 858   2              if(SWITCHfXBR==1)
 859   2          {
 860   3            PWM3init(100);
 861   3          }
 862   2              SWITCHflag2=1;
 863   2          }
 864   1        
 865   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 866   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2);
 867   1          if(ret == SUCCESS)
 868   1              return SUCCESS;
 869   1          else
 870   1              return ERROR;
 871   1      }
 872          
 873          
 874          /******************************************************************************
 875                                          WARNING!!!                     
 876          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 877          ******************************************************************************/
 878          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /*****************************************************************************
              å‡½æ•°åç§° : mcu_firm_update_handle
              åŠŸèƒ½æè¿° : MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
              è¾“å…¥å‚æ•° : value:å›ºä»¶ç¼“å†²åŒº
                         position:å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
                         length:å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
              è¿”å›å‚æ•° : æ— 
              ä½¿ç”¨è¯´æ˜ : MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
              *****************************************************************************/
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                unsigned long addr;
               
                if(length == 0)
                {
              #ifdef ENABLE_BOOT
                  //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                  FlashBuffer.magic_code = FIREWARE_UPDATE_FLAG;
                  
                  if(Earse_Flash(PARA_ADDR) == ERROR)
                    return ERROR;
                  
                  //å†™å…¥å‡çº§æ ‡å¿—
                  if(Write_Flash(PARA_ADDR,(unsigned char *)&FlashBuffer,sizeof(FlashBuffer)) == ERROR)
                    return ERROR;
                  
                  Reset();
              #endif
                }
                else
                {
                  //å›ºä»¶æ•°æ®å¤„ç†
                  addr = FIREWARE_ADDR_H;
                   
                  if(position % 1024 == 0)
                  {
                    if(Earse_Flash(addr + position) == ERROR)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 16  

                      return ERROR;
                  }
                  
                  if(Write_Flash(addr + position,(unsigned char *)value,length) == ERROR)
                    return ERROR;
                }
              
                return SUCCESS;
              }
              #endif
 927          /******************************************************************************
 928                                          WARNING!!!                     
 929          ä»¥ä¸‹å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 930          ******************************************************************************/
 931          
 932          /*****************************************************************************
 933          å‡½æ•°åç§° : dp_download_handle
 934          åŠŸèƒ½æè¿° : dpä¸‹å‘å¤„ç†å‡½æ•°
 935          è¾“å…¥å‚æ•° : dpid:DPåºå·
 936                     value:dpæ•°æ®ç¼“å†²åŒºåœ°å€
 937                     length:dpæ•°æ®é•¿åº¦
 938          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERRO
 939          ä½¿ç”¨è¯´æ˜ : è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 940          *****************************************************************************/
 941          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 942          {
 943   1        /*********************************
 944   1        å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 945   1        å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 946   1        å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 947   1        ***********************************/
 948   1        unsigned char ret;
 949   1        switch(dpid)
 950   1        {
 951   2              case DPID_SWITCH_LED:
 952   2                  //å¼€å…³å¤„ç†å‡½æ•°
 953   2                  ret = dp_download_switch_led_handle(value,length);
 954   2            if(ret==1)
 955   2            {
 956   3              switchcnt ++;
 957   3              if(switchcnt>=5)
 958   3              {
 959   4                switchcnt = 0;
 960   4                          reset_bt_module();
 961   4              }
 962   3            }
 963   2              break;
 964   2              case DPID_BRIGHT_VALUE:
 965   2                  //äº®åº¦å€¼å¤„ç†å‡½æ•°
 966   2                  ret = dp_download_bright_value_handle(value,length);
 967   2                  switchcnt = 0;
 968   2              break;
 969   2              case DPID_CDS:
 970   2                  //å…‰æ•å‚æ•°å¤„ç†å‡½æ•°
 971   2                  ret = dp_download_cds_handle(value,length);
 972   2                  switchcnt = 0;
 973   2              break;
 974   2              case DPID_PIR_DELAY:
 975   2                  //æ„Ÿåº”å»¶æ—¶å¤„ç†å‡½æ•°
 976   2                  ret = dp_download_pir_delay_handle(value,length);
 977   2                  switchcnt = 0;
 978   2              break;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 17  

 979   2              case DPID_SWITCH_XBR:
 980   2                  //æ„Ÿåº”å¼€å…³å¤„ç†å‡½æ•°
 981   2                  ret = dp_download_switch_xbr_handle(value,length);
 982   2                  switchcnt = 0;
 983   2              break;
 984   2              case DPID_STANDBY_TIME:
 985   2                  //ä¼´äº®å»¶æ—¶å¤„ç†å‡½æ•°
 986   2                  ret = dp_download_standby_time_handle(value,length);
 987   2                  switchcnt = 0;
 988   2              break;
 989   2              case DPID_SENSE_STRESS:
 990   2                  //æ„Ÿåº”å¼ºåº¦å¤„ç†å‡½æ•°
 991   2                  ret = dp_download_sense_stress_handle(value,length);
 992   2                  switchcnt = 0;
 993   2              break;
 994   2              case DPID_ADDR:
 995   2                  //è®¾å¤‡åœ°å€å¤„ç†å‡½æ•°
 996   2                  ret = dp_download_addr_handle(value,length);
 997   2                  switchcnt = 0;
 998   2              break;
 999   2              case DPID_ADDREND:
1000   2                  //è®¾å¤‡åœ°å€ç»“æŸå€¼å¤„ç†å‡½æ•°
1001   2                  ret = dp_download_addrend_handle(value,length);
1002   2                  switchcnt = 0;
1003   2              break;
1004   2              case DPID_GROUP:
1005   2                  //è®¾å¤‡ç¾¤ç»„å¤„ç†å‡½æ•°
1006   2                  ret = dp_download_group_handle(value,length);
1007   2                  switchcnt = 0;
1008   2              break;
1009   2              case DPID_TEST_BN0:
1010   2                  //æµ‹è¯•å¼€å…³0å¤„ç†å‡½æ•°
1011   2                  ret = dp_download_test_bn0_handle(value,length);
1012   2                  switchcnt = 0;
1013   2              break;
1014   2              case DPID_TEST_BN1:
1015   2                  //æµ‹è¯•å¼€å…³1å¤„ç†å‡½æ•°
1016   2                  ret = dp_download_test_bn1_handle(value,length);
1017   2                  switchcnt = 0;
1018   2              break;
1019   2              case DPID_TEST_BN2:
1020   2                  //æµ‹è¯•å¼€å…³2å¤„ç†å‡½æ•°
1021   2                  ret = dp_download_test_bn2_handle(value,length);
1022   2                  switchcnt = 0;
1023   2              break;
1024   2              case DPID_SWITCH_LED2:
1025   2                  //ç¯å¼€å…³å¤„ç†å‡½æ•°
1026   2                  ret = dp_download_switch_led2_handle(value,length);
1027   2                  switchcnt = 0;
1028   2              break;
1029   2      
1030   2      
1031   2        default:
1032   2              switchcnt = 0;
1033   2          break;
1034   2        }
1035   1        return ret;
1036   1      }
1037          /*****************************************************************************
1038          å‡½æ•°åç§° : get_download_cmd_total
1039          åŠŸèƒ½æè¿° : è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
1040          è¾“å…¥å‚æ•° : æ— 
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 18  

1041          è¿”å›å‚æ•° : ä¸‹å‘å‘½ä»¤æ€»å’Œ
1042          ä½¿ç”¨è¯´æ˜ : è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
1043          *****************************************************************************/
1044          unsigned char get_download_cmd_total(void)
1045          {
1046   1        return(sizeof(download_cmd) / sizeof(download_cmd[0]));
1047   1      }
1048          
1049          void savevar(void)
1050          {
1051   1        unsigned char i;
1052   1        Flash_EraseBlock(0x2F00);
1053   1        Delay_us_1(10000);
1054   1      
1055   1        i=(TH/1000)>>8;
1056   1        FLASH_WriteData(i,0x2F00+0);
1057   1        Delay_us_1(100);
1058   1        
1059   1          i=(TH/1000)&0xff;
1060   1        FLASH_WriteData(i,0x2F00+1);
1061   1        Delay_us_1(100);
1062   1        
1063   1          i=LIGHT_TH;
1064   1        FLASH_WriteData(i,0x2F00+2);
1065   1        Delay_us_1(100);
1066   1        
1067   1        i=DELAY_NUM>>8;
1068   1        FLASH_WriteData(i,0x2F00+3);
1069   1        Delay_us_1(100);
1070   1        i=DELAY_NUM&0xff;//&0xff;
1071   1        FLASH_WriteData(i,0x2F00+4);
1072   1        Delay_us_1(100);
1073   1        
1074   1        i=lightvalue;
1075   1        FLASH_WriteData(i,0x2F00+5);
1076   1        Delay_us_1(100);
1077   1        
1078   1        i=lowlightDELAY_NUM;
1079   1        FLASH_WriteData(i,0x2F00+6);
1080   1        Delay_us_1(100);
1081   1        
1082   1        i=SWITCHfXBR;//&0xff;
1083   1        FLASH_WriteData(i,0x2F00+7);
1084   1        Delay_us_1(100);
1085   1        
1086   1      //  i=addr;//&0xff;
1087   1      //  FLASH_WriteData(i,0X2F00+7);
1088   1      //  Delay_us_1(100);
1089   1      //  
1090   1      //  i=devgroup;//&0xff;
1091   1      //  FLASH_WriteData(i,0X2F00+8);
1092   1      //  Delay_us_1(100);
1093   1      
1094   1      //  i=addrend;
1095   1      //  FLASH_WriteData(i,0X2F00+9);
1096   1      //  Delay_us_1(100);
1097   1        
1098   1        Flash_EraseBlock(0x2F80);
1099   1        Delay_us_1(10000);
1100   1        FLASH_WriteData(0,0x2F80+0);
1101   1        
1102   1        EA=1;       //-20200927
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 10:11:56 PAGE 19  

1103   1      
1104   1      }
1105          
1106          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2260    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     35    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      46
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

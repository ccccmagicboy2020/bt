C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\protocol.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\protocol.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /****************************************Copyright (c)*************************
   2          **                               ç‰ˆæƒæ‰€æœ‰ (C), 2015-2017, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                                 http://www.tuya.com
   5          **
   6          **--------------æ–‡ä»¶ä¿¡æ¯-------------------------------------------------------
   7          **æ–‡   ä»¶   å: protocol.c
   8          **æ        è¿°: ä¸‹å‘/ä¸ŠæŠ¥æ•°æ®å¤„ç†å‡½æ•°
   9          **ä½¿ ç”¨ è¯´ æ˜ :
  10          
  11                            *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  12          
  13          ** 1ã€ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  14          ** 2ã€DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  15          ** 3ã€å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•°åè¯·å
             -ˆ é™¤è¯¥#err
  16          **
  17          **--------------å½“å‰ç‰ˆæœ¬ä¿®è®¢---------------------------------------------------
  18          ** ç‰ˆ  æœ¬: v1.0
  19          ** æ—¥ã€€æœŸ: 2017å¹´5æœˆ3æ—¥
  20          ** æã€€è¿°: 1:åˆ›å»ºæ¶‚é¸¦bluetoothå¯¹æ¥MCU_SDK
  21          **
  22          **-----------------------------------------------------------------------------
  23          ******************************************************************************/
  24          //#include "include.h"
  25          
  26          #include "bluetooth.h"
  27          #include "string.h"
  28          #include <stdio.h>
  29            
  30          
  31          extern u8 xdata switchcnt;      //å¤ä½æ¨¡å—ç‚¹å‡»æ¬¡æ•°è®¡æ•°
  32          extern u8 xdata reset_bt_bn;    //å¤ä½æ¨¡å—çš„å…¨å±€å˜é‡
  33          extern u8 xdata SWITCHflag2;   //å¼€å…³ç¯çš„å˜é‡
  34          extern u8 xdata SWITCHfXBR;    //å¼€å…³é›·è¾¾çš„å˜é‡
  35          extern u8 xdata lightvalue;    //ç¯äº®å€¼
  36          extern u8 xdata XRBoffbrightvalue;  //å…³é›·è¾¾åçš„ç¯äº®å€¼
  37          extern ulong xdata TH;          //é›·è¾¾æ„Ÿåº”åå·®é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§ä»£è¡¨è¶Šä¸çµæ•
  38          extern u8 xdata LIGHT_TH;       //æ„Ÿå…‰é˜ˆå€¼
  39          extern u16 xdata DELAY_NUM;     //æ„Ÿåº”å»¶æ—¶ï¼Œå•ä½ä¸ºç§’
  40          extern u8 xdata lowlightDELAY_NUM;      //å…³ç¯å»¶æ—¶ï¼Œå•ä½ä¸ºåˆ†é’Ÿ
  41          extern u8 xdata light_ad;               //é‡‡åˆ°çš„å…‰æ„Ÿçš„ç¬æ—¶å€¼
  42          u8 xdata cdsvalue = 0;              //æ„Ÿå…‰é€‰æ‹©å€¼
  43          ulong xdata sensing_th = 0;     //é›·è¾¾æ„Ÿåº”é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§è¶Šçµæ•
  44          extern  u8 idata Linkage_flag;  //è”åŠ¨çš„å¼€å…³çš„å…¨å±€
  45          extern  u8 idata Light_on_flag; //
  46          
  47          //const char xdata led_bn_on[]={"led on"};
  48          //const char xdata led_bn_off[]={"led off"};
  49          //const char xdata radar_bn_on[]={"radar on"};
  50          //const char xdata radar_bn_off[]={"radar off"};
  51          
  52          unsigned char DPID_SWITCH_LED2count = 0;
  53          unsigned char DPID_SWITCH_XBRcount = 0;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 2   

  54          unsigned char DPID_BRIGHT_VALUEcount = 0;
  55          unsigned char DPID_CDScount = 0;
  56          unsigned char DPID_PIR_DELAYcount = 0;
  57          unsigned char DPID_STANDBY_TIMEcount = 0;
  58          unsigned char DPID_SENSE_STRESScount = 0;
  59          
  60          extern u16 idata groupaddr[8];
  61          
  62          //extern TYPE_BUFFER_S FlashBuffer;
  63          void send_data(u8 d);
  64          void reset_bt_module(void);
  65          unsigned char PWM3init(unsigned char ab);
  66          void savevar(void);
  67          void Flash_EraseBlock(unsigned int fui_Address);//flashæ‰‡åŒºæ“¦é™¤
  68          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);//flashå†™å…¥
  69          void Delay_us_1(uint q1);
  70          
  71          void reset_bt_module(void)
  72          {
  73   1        send_data(0x55);
  74   1        send_data(0xAA);
  75   1        send_data(0x00);
  76   1        send_data(0x04);
  77   1        send_data(0x00);
  78   1        send_data(0x00);
  79   1        send_data(0x03);
  80   1      }
  81          
  82          /******************************************************************************
  83                                          ç§»æ¤é¡»çŸ¥:
  84          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„bt_uart_service()å‡½æ•°
  85          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  86          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  87          ******************************************************************************/
  88          
  89                   
  90          /******************************************************************************
  91                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  92          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°btç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "bt.h"
  93          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„bt_protocol_init()å‡½æ•°
  94          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  95          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  96          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„bt_uart_service()å‡½æ•°
  97          ******************************************************************************/
  98          
  99          /******************************************************************************
 100                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
 101                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
 102          ******************************************************************************/
 103          const DOWNLOAD_CMD_S xdata download_cmd[] =
 104          {
 105            {DPID_SWITCH_LED, DP_TYPE_BOOL},
 106            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
 107            {DPID_CDS, DP_TYPE_ENUM},
 108            {DPID_PIR_DELAY, DP_TYPE_VALUE},
 109            {DPID_SWITCH_XBR, DP_TYPE_BOOL},
 110            {DPID_STANDBY_TIME, DP_TYPE_VALUE},
 111            {DPID_SENSE_STRESS, DP_TYPE_VALUE},
 112            {DPID_ADDR, DP_TYPE_VALUE},
 113            {DPID_ADDREND, DP_TYPE_VALUE},
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 3   

 114            {DPID_GROUP, DP_TYPE_VALUE},
 115            {DPID_DEBUG, DP_TYPE_STRING},
 116            //{DPID_TEST_BN0, DP_TYPE_BOOL},
 117            //{DPID_TEST_BN1, DP_TYPE_BOOL},
 118            //{DPID_TEST_BN2, DP_TYPE_BOOL},
 119            {DPID_SWITCH_LED2, DP_TYPE_BOOL},
 120            {DPID_SWITCH_LINKAGE, DP_TYPE_BOOL},
 121          };
 122          
 123          
 124          
 125          
 126          /******************************************************************************
 127                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 128          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
 129          ******************************************************************************/
 130          
 131          /*****************************************************************************
 132          å‡½æ•°åç§° : uart_transmit_output
 133          åŠŸèƒ½æè¿° : å‘æ•°æ®å¤„ç†
 134          è¾“å…¥å‚æ•° : value:ä¸²å£æ”¶åˆ°å­—èŠ‚æ•°æ®
 135          è¿”å›å‚æ•° : æ— 
 136          ä½¿ç”¨è¯´æ˜ : è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²
             -å£å‘é€å‡½æ•°
 137          *****************************************************************************/
 138          void uart_transmit_output(unsigned char value)
 139          {
 140   1      // #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 141   1          send_data(value);
 142   1        
 143   1      /*
 144   1        //ç¤ºä¾‹:
 145   1        extern void Uart_PutChar(unsigned char value);
 146   1        Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 147   1      */  
 148   1      }
 149          /******************************************************************************
 150                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 151          1:APPä¸‹å‘æ•°æ®å¤„ç†
 152          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 153          ******************************************************************************/
 154          
 155          /******************************************************************************
 156                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 157          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 158            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 159            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 160            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 161          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 162          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 163          ******************************************************************************/
 164          
 165          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 166          
 167          /*****************************************************************************
 168          å‡½æ•°åç§° : all_data_update
 169          åŠŸèƒ½æè¿° : ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 170          è¾“å…¥å‚æ•° : æ— 
 171          è¿”å›å‚æ•° : æ— 
 172          ä½¿ç”¨è¯´æ˜ : æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨;
 173                     MCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½;åŒ…æ‹¬åªä¸ŠæŠ¥å’Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 174          *****************************************************************************/
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 4   

 175          void all_data_update(void)
 176          {
 177   1          u8 light;
 178   1          u8 radius;
 179   1        //#error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 180   1        //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸ŠæŠ¥
             -å‡½æ•°
 181   1        
 182   1          mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn); //å¤ä½æ¨¡å—
 183   1          mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2); //ç¯çš„å¼€å…³
 184   1          mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 185   1      
 186   1        if(LIGHT_TH==255)
 187   1          light=0;
 188   1        else if(LIGHT_TH==200)
 189   1          light=2;
 190   1        else if(LIGHT_TH==40)
 191   1          light=3;    
 192   1        else if(LIGHT_TH==20)
 193   1          light=4;
 194   1        else //if(LIGHT_TH==200)
 195   1          light=5;
 196   1      
 197   1          mcu_dp_enum_update(DPID_CDS, light); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 198   1          mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 199   1          mcu_dp_bool_update(DPID_SWITCH_XBR, SWITCHfXBR); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 200   1          mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 201   1      
 202   1        radius=TH/10000;
 203   1        radius=50-radius;
 204   1      
 205   1          mcu_dp_value_update(DPID_SENSE_STRESS, radius); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 206   1      
 207   1          mcu_dp_value_update(DPID_ADDR, 10); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 208   1          mcu_dp_value_update(DPID_ADDREND, 11); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 209   1          mcu_dp_value_update(DPID_GROUP, 12); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 210   1      
 211   1      
 212   1          mcu_dp_string_update(DPID_DEBUG, "1012", 4); //STRINGå‹æ•°æ®ä¸ŠæŠ¥;
 213   1      
 214   1      
 215   1          //mcu_dp_bool_update(DPID_TEST_BN0,å½“å‰æµ‹è¯•å¼€å…³0); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 216   1          //mcu_dp_bool_update(DPID_TEST_BN1,å½“å‰æµ‹è¯•å¼€å…³1); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 217   1          //mcu_dp_bool_update(DPID_TEST_BN2,å½“å‰æµ‹è¯•å¼€å…³2); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 218   1        
 219   1        mcu_dp_bool_update(DPID_SWITCH_LINKAGE,Linkage_flag); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 220   1      
 221   1      
 222   1      
 223   1      }
 224          
 225          
 226          /******************************************************************************
 227                                          WARNING!!!    
 228                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 229          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 230          ******************************************************************************/
 231          
 232          /*****************************************************************************
 233          å‡½æ•°åç§° : dp_download_switch_led_handle
 234          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LEDçš„å¤„ç†å‡½æ•°
 235          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 5   

 236                  : length:æ•°æ®é•¿åº¦
 237          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 238          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 239          *****************************************************************************/
 240          static unsigned char dp_download_switch_led_handle(const unsigned char value[], unsigned short length)
 241          {
 242   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 243   1          unsigned char ret;
 244   1          //0:å…³/1:å¼€
 245   1          unsigned char switch_led;
 246   1          
 247   1          switch_led = mcu_get_dp_download_bool(value,length);
 248   1      
 249   1          reset_bt_bn = switch_led;
 250   1        
 251   1          
 252   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 253   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn);
 254   1          if(ret == SUCCESS)
 255   1              return SUCCESS;
 256   1          else
 257   1              return ERROR;
 258   1      }
 259          /*****************************************************************************
 260          å‡½æ•°åç§° : dp_download_bright_value_handle
 261          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 262          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 263                  : length:æ•°æ®é•¿åº¦
 264          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 265          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 266          *****************************************************************************/
 267          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 268          {
 269   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 270   1          unsigned char ret;
 271   1          unsigned long bright_value;
 272   1          unsigned char i;
 273   1          
 274   1          bright_value = mcu_get_dp_download_value(value,length);
 275   1        
 276   1        DPID_BRIGHT_VALUEcount++;
 277   1        if(bright_value==lightvalue)
 278   1        {
 279   2      /*    if(DPID_BRIGHT_VALUEcount<2)
 280   2          {
 281   2            //DPID_BRIGHT_VALUEcount = 0;
 282   2            
 283   2            for(i=0;i<8;i++)
 284   2            {
 285   2              if(groupaddr[i] != 0)
 286   2              {
 287   2                mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 288   2              }
 289   2            }
 290   2          } */
 291   2        }
 292   1        else
 293   1        {
 294   2          DPID_BRIGHT_VALUEcount=0;
 295   2          for(i=0;i<8;i++)
 296   2          {
 297   3            if(groupaddr[i] != 0)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 6   

 298   3            {
 299   4              mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 300   4            }
 301   3          }
 302   2        } 
 303   1        
 304   1          lightvalue = bright_value;
 305   1      
 306   1        if(SWITCHfXBR==0)
 307   1        {
 308   2          XRBoffbrightvalue = bright_value;
 309   2        }
 310   1        
 311   1        savevar();
 312   1          
 313   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 314   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue);
 315   1      
 316   1          if(ret == SUCCESS)
 317   1              return SUCCESS;
 318   1          else
 319   1              return ERROR;
 320   1      }
 321          /*****************************************************************************
 322          å‡½æ•°åç§° : dp_download_cds_handle
 323          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_CDSçš„å¤„ç†å‡½æ•°
 324          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 325                  : length:æ•°æ®é•¿åº¦
 326          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 327          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 328          *****************************************************************************/
 329          static unsigned char dp_download_cds_handle(const unsigned char value[], unsigned short length)
 330          {
 331   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 332   1          unsigned char ret;
 333   1          unsigned char cds;
 334   1          unsigned char i;
 335   1          
 336   1          cds = mcu_get_dp_download_enum(value,length);
 337   1        
 338   1        DPID_CDScount++;
 339   1        if(cds==cdsvalue)
 340   1        {
 341   2          if(DPID_CDScount<2)
 342   2          {
 343   3      /*      for(i=0;i<8;i++)
 344   3            {
 345   3              if(groupaddr[i] != 0)
 346   3              {
 347   3                mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 348   3              }
 349   3            } */
 350   3          }
 351   2          if((cds==5)&&(light_ad!=LIGHT_TH))
 352   2          {
 353   3            DPID_CDScount=0;
 354   3          }
 355   2        }
 356   1        else
 357   1        {
 358   2          DPID_CDScount=0;
 359   2          for(i=0;i<8;i++)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 7   

 360   2          {
 361   3            if(groupaddr[i] != 0)
 362   3            {
 363   4              mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 364   4            }
 365   3          }
 366   2        } 
 367   1        
 368   1          switch(cds) {
 369   2              case 0:   //2000LUS
 370   2            LIGHT_TH=255;//cds*4;
 371   2              break;
 372   2              
 373   2              case 1:   //300LUX
 374   2            LIGHT_TH=255;//cds*4;
 375   2              break;
 376   2              
 377   2              case 2:   //50LUX
 378   2            LIGHT_TH=200;
 379   2              break;
 380   2              
 381   2              case 3: //10LUX
 382   2            LIGHT_TH=40;
 383   2              break;
 384   2              
 385   2              case 4: //5LUX
 386   2            LIGHT_TH=20;
 387   2              break;
 388   2              
 389   2          case 5:
 390   2            LIGHT_TH = light_ad;
 391   2          break;
 392   2              
 393   2              default:
 394   2          
 395   2              break;
 396   2          }
 397   1      
 398   1          cdsvalue = cds;
 399   1      
 400   1          savevar();
 401   1          //sprintf(temp_str, "%3d", LIGHT_TH);
 402   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));
 403   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 404   1          ret = mcu_dp_enum_update(DPID_CDS, cdsvalue);
 405   1          if(ret == SUCCESS)
 406   1              return SUCCESS;
 407   1          else
 408   1              return ERROR;
 409   1      }
 410          /*****************************************************************************
 411          å‡½æ•°åç§° : dp_download_pir_delay_handle
 412          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PIR_DELAYçš„å¤„ç†å‡½æ•°
 413          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 414                  : length:æ•°æ®é•¿åº¦
 415          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 416          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 417          *****************************************************************************/
 418          static unsigned char dp_download_pir_delay_handle(const unsigned char value[], unsigned short length)
 419          {
 420   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 421   1          unsigned char ret;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 8   

 422   1          unsigned long pir_delay;
 423   1          unsigned char i;
 424   1          
 425   1          pir_delay = mcu_get_dp_download_value(value,length);
 426   1          /*
 427   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 428   1          */
 429   1        
 430   1        DPID_PIR_DELAYcount++;
 431   1        if(pir_delay==DELAY_NUM)
 432   1        {
 433   2      /*    if(DPID_PIR_DELAYcount<2)
 434   2          {
 435   2            for(i=0;i<8;i++)
 436   2            {
 437   2              if(groupaddr[i] != 0)
 438   2              {
 439   2                mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 440   2              }
 441   2            }
 442   2          } */
 443   2        }
 444   1        else
 445   1        {
 446   2          DPID_PIR_DELAYcount=0;
 447   2          for(i=0;i<8;i++)
 448   2          {
 449   3            if(groupaddr[i] != 0)
 450   3            {
 451   4              mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 452   4            }
 453   3          }
 454   2        }
 455   1        
 456   1          DELAY_NUM = pir_delay;
 457   1        savevar();
 458   1          
 459   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 460   1          ret = mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM);
 461   1          if(ret == SUCCESS)
 462   1              return SUCCESS;
 463   1          else
 464   1              return ERROR;
 465   1      }
 466          /*****************************************************************************
 467          å‡½æ•°åç§° : dp_download_switch_xbr_handle
 468          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_XBRçš„å¤„ç†å‡½æ•°
 469          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 470                  : length:æ•°æ®é•¿åº¦
 471          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 472          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 473          *****************************************************************************/
 474          static unsigned char dp_download_switch_xbr_handle(const unsigned char value[], unsigned short length)
 475          {
 476   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 477   1          unsigned char ret;
 478   1          //0:å…³/1:å¼€
 479   1          unsigned char switch_xbr;
 480   1          unsigned char i;
 481   1          
 482   1          switch_xbr = mcu_get_dp_download_bool(value,length);
 483   1        
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 9   

 484   1        DPID_SWITCH_XBRcount++;
 485   1        if(switch_xbr==SWITCHfXBR)
 486   1        {
 487   2      /*    if(DPID_SWITCH_XBRcount<2)
 488   2          {
 489   2            for(i=0;i<8;i++)
 490   2            {
 491   2              if(groupaddr[i] != 0)
 492   2              {
 493   2                mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 494   2              }
 495   2            }
 496   2          } */
 497   2        }
 498   1        else
 499   1        {
 500   2          DPID_SWITCH_XBRcount=0;
 501   2          for(i=0;i<8;i++)
 502   2          {
 503   3            if(groupaddr[i] != 0)
 504   3            {
 505   4              mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 506   4            }
 507   3          }
 508   2        
 509   2        }
 510   1        
 511   1          if(switch_xbr == 0) {
 512   2              //å¼€å…³å…³
 513   2              SWITCHfXBR = 0;
 514   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_off, strlen(radar_bn_off));
 515   2          }else {
 516   2              //å¼€å…³å¼€
 517   2              SWITCHfXBR = 1;
 518   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_on, strlen(radar_bn_on));
 519   2          }
 520   1        
 521   1          savevar();
 522   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 523   1          ret = mcu_dp_bool_update(DPID_SWITCH_XBR,SWITCHfXBR);
 524   1          if(ret == SUCCESS)
 525   1              return SUCCESS;
 526   1          else
 527   1              return ERROR;
 528   1      }
 529          /*****************************************************************************
 530          å‡½æ•°åç§° : dp_download_standby_time_handle
 531          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_STANDBY_TIMEçš„å¤„ç†å‡½æ•°
 532          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 533                  : length:æ•°æ®é•¿åº¦
 534          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 535          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 536          *****************************************************************************/
 537          static unsigned char dp_download_standby_time_handle(const unsigned char value[], unsigned short length)
 538          {
 539   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 540   1          unsigned char ret;
 541   1          unsigned long standby_time;
 542   1          unsigned char i;
 543   1          
 544   1          standby_time = mcu_get_dp_download_value(value,length);
 545   1          /*
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 10  

 546   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 547   1          
 548   1          */
 549   1        DPID_STANDBY_TIMEcount++;
 550   1        if(standby_time==lowlightDELAY_NUM)
 551   1        {
 552   2      /*    if(DPID_STANDBY_TIMEcount<2)
 553   2          {
 554   2            for(i=0;i<8;i++)
 555   2            {
 556   2              if(groupaddr[i] != 0)
 557   2              {
 558   2                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 559   2              }
 560   2            }
 561   2          } */
 562   2        }
 563   1        else
 564   1        {
 565   2          DPID_STANDBY_TIMEcount=0;
 566   2          for(i=0;i<8;i++)
 567   2            {
 568   3              if(groupaddr[i] != 0)
 569   3              {
 570   4                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 571   4              }
 572   3            }
 573   2        
 574   2        }
 575   1        
 576   1          lowlightDELAY_NUM=standby_time;
 577   1          
 578   1          savevar();
 579   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 580   1          ret = mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM);
 581   1          if(ret == SUCCESS)
 582   1              return SUCCESS;
 583   1          else
 584   1              return ERROR;
 585   1      }
 586          /*****************************************************************************
 587          å‡½æ•°åç§° : dp_download_sense_stress_handle
 588          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SENSE_STRESSçš„å¤„ç†å‡½æ•°
 589          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 590                  : length:æ•°æ®é•¿åº¦
 591          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 592          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 593          *****************************************************************************/
 594          static unsigned char dp_download_sense_stress_handle(const unsigned char value[], unsigned short length)
 595          {
 596   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 597   1          unsigned char ret;
 598   1          unsigned long sense_stress;
 599   1          unsigned char i;
 600   1          
 601   1          sense_stress = mcu_get_dp_download_value(value,length);
 602   1          /*
 603   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 604   1          
 605   1          */
 606   1        DPID_SENSE_STRESScount++;
 607   1        if(sense_stress==sensing_th)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 11  

 608   1        {
 609   2      /*    if(DPID_SENSE_STRESScount<2)
 610   2          {
 611   2            for(i=0;i<8;i++)
 612   2            {
 613   2              if(groupaddr[i] != 0)
 614   2              {
 615   2                mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 616   2              }
 617   2            }
 618   2          } */
 619   2        }
 620   1        else
 621   1        {
 622   2          DPID_SENSE_STRESScount=0;
 623   2          for(i=0;i<8;i++)
 624   2          {
 625   3            if(groupaddr[i] != 0)
 626   3            {
 627   4              mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 628   4            }
 629   3          }
 630   2        } 
 631   1        
 632   1        sensing_th = sense_stress;
 633   1        TH=(50-sense_stress)*10000;
 634   1          
 635   1        savevar();
 636   1          
 637   1          //sprintf(temp_str, "%6d", TH);
 638   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));    
 639   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 640   1          ret = mcu_dp_value_update(DPID_SENSE_STRESS, sensing_th);
 641   1          if(ret == SUCCESS)
 642   1              return SUCCESS;
 643   1          else
 644   1              return ERROR;
 645   1      }
 646          /*****************************************************************************
 647          å‡½æ•°åç§° : dp_download_addr_handle
 648          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_ADDRçš„å¤„ç†å‡½æ•°
 649          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 650                  : length:æ•°æ®é•¿åº¦
 651          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 652          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 653          *****************************************************************************/
 654          static unsigned char dp_download_addr_handle(const unsigned char value[], unsigned short length)
 655          {
 656   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 657   1          unsigned char ret;
 658   1          unsigned long addr;
 659   1          
 660   1          addr = mcu_get_dp_download_value(value,length);
 661   1          /*
 662   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 663   1          
 664   1          */
 665   1          
 666   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 667   1          ret = mcu_dp_value_update(DPID_ADDR,addr);
 668   1          if(ret == SUCCESS)
 669   1              return SUCCESS;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 12  

 670   1          else
 671   1              return ERROR;
 672   1      }
 673          /*****************************************************************************
 674          å‡½æ•°åç§° : dp_download_addrend_handle
 675          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_ADDRENDçš„å¤„ç†å‡½æ•°
 676          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 677                  : length:æ•°æ®é•¿åº¦
 678          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 679          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 680          *****************************************************************************/
 681          static unsigned char dp_download_addrend_handle(const unsigned char value[], unsigned short length)
 682          {
 683   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 684   1          unsigned char ret;
 685   1          unsigned long addrend;
 686   1          
 687   1          addrend = mcu_get_dp_download_value(value,length);
 688   1          /*
 689   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 690   1          
 691   1          */
 692   1          
 693   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 694   1          ret = mcu_dp_value_update(DPID_ADDREND,addrend);
 695   1          if(ret == SUCCESS)
 696   1              return SUCCESS;
 697   1          else
 698   1              return ERROR;
 699   1      }
 700          /*****************************************************************************
 701          å‡½æ•°åç§° : dp_download_group_handle
 702          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_GROUPçš„å¤„ç†å‡½æ•°
 703          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 704                  : length:æ•°æ®é•¿åº¦
 705          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 706          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 707          *****************************************************************************/
 708          static unsigned char dp_download_group_handle(const unsigned char value[], unsigned short length)
 709          {
 710   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 711   1          unsigned char ret;
 712   1          unsigned long group;
 713   1          
 714   1          group = mcu_get_dp_download_value(value,length);
 715   1          /*
 716   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 717   1          
 718   1          */
 719   1          
 720   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 721   1          ret = mcu_dp_value_update(DPID_GROUP,group);
 722   1          if(ret == SUCCESS)
 723   1              return SUCCESS;
 724   1          else
 725   1              return ERROR;
 726   1      }
 727          /*****************************************************************************
 728          å‡½æ•°åç§° : dp_download_test_bn0_handle
 729          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN0çš„å¤„ç†å‡½æ•°
 730          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 731                  : length:æ•°æ®é•¿åº¦
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 13  

 732          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 733          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 734          *****************************************************************************/
 735          /* static unsigned char dp_download_test_bn0_handle(const unsigned char value[], unsigned short length)
 736          {
 737              //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 738              unsigned char ret;
 739              //0:å…³/1:å¼€
 740              unsigned char test_bn0;
 741              
 742              test_bn0 = mcu_get_dp_download_bool(value,length);
 743              if(test_bn0 == 0) {
 744                  //å¼€å…³å…³
 745              }else {
 746                  //å¼€å…³å¼€
 747              }
 748            
 749              //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 750              ret = mcu_dp_bool_update(DPID_TEST_BN0,test_bn0);
 751              if(ret == SUCCESS)
 752                  return SUCCESS;
 753              else
 754                  return ERROR;
 755          } */
 756          /*****************************************************************************
 757          å‡½æ•°åç§° : dp_download_test_bn1_handle
 758          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN1çš„å¤„ç†å‡½æ•°
 759          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 760                  : length:æ•°æ®é•¿åº¦
 761          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 762          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 763          *****************************************************************************/
 764          /* static unsigned char dp_download_test_bn1_handle(const unsigned char value[], unsigned short length)
 765          {
 766              //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 767              unsigned char ret;
 768              //0:å…³/1:å¼€
 769              unsigned char test_bn1;
 770              
 771              test_bn1 = mcu_get_dp_download_bool(value,length);
 772              if(test_bn1 == 0) {
 773                  //å¼€å…³å…³
 774              }else {
 775                  //å¼€å…³å¼€
 776              }
 777            
 778              //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 779              ret = mcu_dp_bool_update(DPID_TEST_BN1,test_bn1);
 780              if(ret == SUCCESS)
 781                  return SUCCESS;
 782              else
 783                  return ERROR;
 784          } */
 785          /*****************************************************************************
 786          å‡½æ•°åç§° : dp_download_test_bn2_handle
 787          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEST_BN2çš„å¤„ç†å‡½æ•°
 788          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 789                  : length:æ•°æ®é•¿åº¦
 790          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 791          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 792          *****************************************************************************/
 793          /* static unsigned char dp_download_test_bn2_handle(const unsigned char value[], unsigned short length)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 14  

 794          {
 795              //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 796              unsigned char ret;
 797              //0:å…³/1:å¼€
 798              unsigned char test_bn2;
 799              
 800              test_bn2 = mcu_get_dp_download_bool(value,length);
 801              if(test_bn2 == 0) {
 802                  //å¼€å…³å…³
 803              }else {
 804                  //å¼€å…³å¼€
 805              }
 806            
 807              //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 808              ret = mcu_dp_bool_update(DPID_TEST_BN2,test_bn2);
 809              if(ret == SUCCESS)
 810                  return SUCCESS;
 811              else
 812                  return ERROR;
 813          } */
 814          /*****************************************************************************
 815          å‡½æ•°åç§° : dp_download_switch_led2_handle
 816          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LED2çš„å¤„ç†å‡½æ•°
 817          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 818                  : length:æ•°æ®é•¿åº¦
 819          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 820          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 821          *****************************************************************************/
 822          static unsigned char dp_download_switch_led2_handle(const unsigned char value[], unsigned short length)
 823          {
 824   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 825   1          unsigned char ret;
 826   1          //0:å…³/1:å¼€
 827   1          unsigned char switch_led2;
 828   1          unsigned char i;
 829   1          
 830   1          switch_led2 = mcu_get_dp_download_bool(value,length);
 831   1      
 832   1          DPID_SWITCH_LED2count++;
 833   1          if(switch_led2==SWITCHflag2)
 834   1          {
 835   2      /*      if(DPID_SWITCH_LED2count<2)
 836   2            {
 837   2              for(i=0;i<8;i++)
 838   2              {
 839   2                if(groupaddr[i] != 0)
 840   2                {
 841   2                  mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 842   2                }
 843   2              }
 844   2            } */
 845   2          }
 846   1          else
 847   1          {
 848   2            DPID_SWITCH_LED2count=0;
 849   2            for(i=0;i<8;i++)
 850   2            {
 851   3              if(groupaddr[i] != 0)
 852   3              {
 853   4                mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 854   4              }
 855   3            }   
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 15  

 856   2      
 857   2          }
 858   1      
 859   1          if(switch_led2 == 0) {
 860   2              //ç¯å¼€å…³å…³
 861   2              SWITCHflag2=0;
 862   2          }else {
 863   2              //ç¯å¼€å…³å¼€
 864   2              //mcu_dp_string_update(DPID_DEBUG, led_bn_on, strlen(led_bn_on));
 865   2              if(SWITCHfXBR==1)
 866   2          {
 867   3            Light_on_flag=1;
 868   3          }
 869   2              SWITCHflag2=1;
 870   2          }
 871   1        
 872   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 873   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2);
 874   1          if(ret == SUCCESS)
 875   1              return SUCCESS;
 876   1          else
 877   1              return ERROR;
 878   1      }
 879          /*****************************************************************************
 880          å‡½æ•°åç§° : dp_download_switch_linkage_handle
 881          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LINKAGEçš„å¤„ç†å‡½æ•°
 882          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 883                  : length:æ•°æ®é•¿åº¦
 884          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 885          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 886          *****************************************************************************/
 887          static unsigned char dp_download_switch_linkage_handle(const unsigned char value[], unsigned short length)
 888          {
 889   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 890   1          unsigned char ret;
 891   1          //0:å…³/1:å¼€
 892   1          unsigned char switch_Linkage;
 893   1          unsigned char i;
 894   1          switch_Linkage = mcu_get_dp_download_bool(value,length);
 895   1          
 896   1        if(switch_Linkage==Linkage_flag)
 897   1        {
 898   2          //
 899   2        }
 900   1        else
 901   1        {
 902   2          for(i=0;i<8;i++)
 903   2          {
 904   3            if(groupaddr[i] != 0)
 905   3            {
 906   4              mcu_dp_bool_mesh_update(DPID_SWITCH_LINKAGE,switch_Linkage,groupaddr[i]);
 907   4            }
 908   3          }
 909   2        }
 910   1          if(switch_Linkage == 0) {
 911   2              //é›·è¾¾å¼€å…³å…³
 912   2              //LIGHT_OFF;
 913   2              //PWM3init(0);
 914   2              Linkage_flag=0;
 915   2          }else {
 916   2              //é›·è¾¾å¼€å…³å¼€
 917   2              //LIGHT_ON;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 16  

 918   2              //PWM3init(100);
 919   2              Linkage_flag=1;
 920   2          }
 921   1          
 922   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 923   1          ret = mcu_dp_bool_update(DPID_SWITCH_LINKAGE,switch_Linkage);
 924   1          if(ret == SUCCESS)
 925   1              return SUCCESS;
 926   1          else
 927   1              return ERROR;
 928   1      }
 929          
 930          /******************************************************************************
 931                                          WARNING!!!                     
 932          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 933          ******************************************************************************/
 934          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /*****************************************************************************
              å‡½æ•°åç§° : mcu_firm_update_handle
              åŠŸèƒ½æè¿° : MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
              è¾“å…¥å‚æ•° : value:å›ºä»¶ç¼“å†²åŒº
                         position:å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
                         length:å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
              è¿”å›å‚æ•° : æ— 
              ä½¿ç”¨è¯´æ˜ : MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
              *****************************************************************************/
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                unsigned long addr;
               
                if(length == 0)
                {
              #ifdef ENABLE_BOOT
                  //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                  FlashBuffer.magic_code = FIREWARE_UPDATE_FLAG;
                  
                  if(Earse_Flash(PARA_ADDR) == ERROR)
                    return ERROR;
                  
                  //å†™å…¥å‡çº§æ ‡å¿—
                  if(Write_Flash(PARA_ADDR,(unsigned char *)&FlashBuffer,sizeof(FlashBuffer)) == ERROR)
                    return ERROR;
                  
                  Reset();
              #endif
                }
                else
                {
                  //å›ºä»¶æ•°æ®å¤„ç†
                  addr = FIREWARE_ADDR_H;
                   
                  if(position % 1024 == 0)
                  {
                    if(Earse_Flash(addr + position) == ERROR)
                      return ERROR;
                  }
                  
                  if(Write_Flash(addr + position,(unsigned char *)value,length) == ERROR)
                    return ERROR;
                }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 17  

              
                return SUCCESS;
              }
              #endif
 983          /******************************************************************************
 984                                          WARNING!!!                     
 985          ä»¥ä¸‹å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 986          ******************************************************************************/
 987          
 988          /*****************************************************************************
 989          å‡½æ•°åç§° : dp_download_handle
 990          åŠŸèƒ½æè¿° : dpä¸‹å‘å¤„ç†å‡½æ•°
 991          è¾“å…¥å‚æ•° : dpid:DPåºå·
 992                     value:dpæ•°æ®ç¼“å†²åŒºåœ°å€
 993                     length:dpæ•°æ®é•¿åº¦
 994          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERRO
 995          ä½¿ç”¨è¯´æ˜ : è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 996          *****************************************************************************/
 997          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 998          {
 999   1        /*********************************
1000   1        å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
1001   1        å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
1002   1        å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
1003   1        ***********************************/
1004   1        unsigned char ret;
1005   1        switch(dpid)
1006   1        {
1007   2              case DPID_SWITCH_LED:
1008   2                  //å¼€å…³å¤„ç†å‡½æ•°
1009   2                  ret = dp_download_switch_led_handle(value,length);
1010   2            if(ret==1)
1011   2            {
1012   3              switchcnt ++;
1013   3              if(switchcnt>=5)
1014   3              {
1015   4                switchcnt = 0;
1016   4                          reset_bt_module();
1017   4              }
1018   3            }
1019   2              break;
1020   2              case DPID_BRIGHT_VALUE:
1021   2                  //äº®åº¦å€¼å¤„ç†å‡½æ•°
1022   2                  ret = dp_download_bright_value_handle(value,length);
1023   2                  switchcnt = 0;
1024   2              break;
1025   2              case DPID_CDS:
1026   2                  //å…‰æ•å‚æ•°å¤„ç†å‡½æ•°
1027   2                  ret = dp_download_cds_handle(value,length);
1028   2                  switchcnt = 0;
1029   2              break;
1030   2              case DPID_PIR_DELAY:
1031   2                  //æ„Ÿåº”å»¶æ—¶å¤„ç†å‡½æ•°
1032   2                  ret = dp_download_pir_delay_handle(value,length);
1033   2                  switchcnt = 0;
1034   2              break;
1035   2              case DPID_SWITCH_XBR:
1036   2                  //æ„Ÿåº”å¼€å…³å¤„ç†å‡½æ•°
1037   2                  ret = dp_download_switch_xbr_handle(value,length);
1038   2                  switchcnt = 0;
1039   2              break;
1040   2              case DPID_STANDBY_TIME:
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 18  

1041   2                  //ä¼´äº®å»¶æ—¶å¤„ç†å‡½æ•°
1042   2                  ret = dp_download_standby_time_handle(value,length);
1043   2                  switchcnt = 0;
1044   2              break;
1045   2              case DPID_SENSE_STRESS:
1046   2                  //æ„Ÿåº”å¼ºåº¦å¤„ç†å‡½æ•°
1047   2                  ret = dp_download_sense_stress_handle(value,length);
1048   2                  switchcnt = 0;
1049   2              break;
1050   2              case DPID_ADDR:
1051   2                  //è®¾å¤‡åœ°å€å¤„ç†å‡½æ•°
1052   2                  ret = dp_download_addr_handle(value,length);
1053   2                  switchcnt = 0;
1054   2              break;
1055   2              case DPID_ADDREND:
1056   2                  //è®¾å¤‡åœ°å€ç»“æŸå€¼å¤„ç†å‡½æ•°
1057   2                  ret = dp_download_addrend_handle(value,length);
1058   2                  switchcnt = 0;
1059   2              break;
1060   2              case DPID_GROUP:
1061   2                  //è®¾å¤‡ç¾¤ç»„å¤„ç†å‡½æ•°
1062   2                  ret = dp_download_group_handle(value,length);
1063   2                  switchcnt = 0;
1064   2              break;
1065   2      /*         case DPID_TEST_BN0:
1066   2                  //æµ‹è¯•å¼€å…³0å¤„ç†å‡½æ•°
1067   2                  ret = dp_download_test_bn0_handle(value,length);
1068   2                  switchcnt = 0;
1069   2              break;
1070   2              case DPID_TEST_BN1:
1071   2                  //æµ‹è¯•å¼€å…³1å¤„ç†å‡½æ•°
1072   2                  ret = dp_download_test_bn1_handle(value,length);
1073   2                  switchcnt = 0;
1074   2              break;
1075   2              case DPID_TEST_BN2:
1076   2                  //æµ‹è¯•å¼€å…³2å¤„ç†å‡½æ•°
1077   2                  ret = dp_download_test_bn2_handle(value,length);
1078   2                  switchcnt = 0;
1079   2              break; */
1080   2              case DPID_SWITCH_LED2:
1081   2                  //ç¯å¼€å…³å¤„ç†å‡½æ•°
1082   2                  ret = dp_download_switch_led2_handle(value,length);
1083   2                  switchcnt = 0;
1084   2              break;
1085   2              case DPID_SWITCH_LINKAGE:
1086   2                  //è”åŠ¨ å¤„ç†å‡½æ•°
1087   2                  ret = dp_download_switch_linkage_handle(value,length);
1088   2                  switchcnt = 0;
1089   2              break;
1090   2      
1091   2        default:
1092   2              switchcnt = 0;
1093   2          break;
1094   2        }
1095   1        return ret;
1096   1      }
1097          /*****************************************************************************
1098          å‡½æ•°åç§° : get_download_cmd_total
1099          åŠŸèƒ½æè¿° : è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
1100          è¾“å…¥å‚æ•° : æ— 
1101          è¿”å›å‚æ•° : ä¸‹å‘å‘½ä»¤æ€»å’Œ
1102          ä½¿ç”¨è¯´æ˜ : è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 19  

1103          *****************************************************************************/
1104          unsigned char get_download_cmd_total(void)
1105          {
1106   1        return(sizeof(download_cmd) / sizeof(download_cmd[0]));
1107   1      }
1108          
1109          void savevar(void)
1110          {
1111   1        unsigned char i;
1112   1        Flash_EraseBlock(0x2F00);
1113   1        Delay_us_1(10000);
1114   1      
1115   1        i=(TH/1000)>>8;
1116   1        FLASH_WriteData(i,0x2F00+0);
1117   1        Delay_us_1(100);
1118   1        
1119   1          i=(TH/1000)&0xff;
1120   1        FLASH_WriteData(i,0x2F00+1);
1121   1        Delay_us_1(100);
1122   1        
1123   1          i=LIGHT_TH;
1124   1        FLASH_WriteData(i,0x2F00+2);
1125   1        Delay_us_1(100);
1126   1        
1127   1        i=DELAY_NUM>>8;
1128   1        FLASH_WriteData(i,0x2F00+3);
1129   1        Delay_us_1(100);
1130   1        i=DELAY_NUM&0xff;//&0xff;
1131   1        FLASH_WriteData(i,0x2F00+4);
1132   1        Delay_us_1(100);
1133   1        
1134   1        i=lightvalue;
1135   1        FLASH_WriteData(i,0x2F00+5);
1136   1        Delay_us_1(100);
1137   1        
1138   1        i=lowlightDELAY_NUM;
1139   1        FLASH_WriteData(i,0x2F00+6);
1140   1        Delay_us_1(100);
1141   1        
1142   1        i=SWITCHfXBR;//&0xff;
1143   1        FLASH_WriteData(i,0x2F00+7);
1144   1        Delay_us_1(100);
1145   1        
1146   1      //  i=addr;//&0xff;
1147   1      //  FLASH_WriteData(i,0X2F00+7);
1148   1      //  Delay_us_1(100);
1149   1      //  
1150   1      //  i=devgroup;//&0xff;
1151   1      //  FLASH_WriteData(i,0X2F00+8);
1152   1      //  Delay_us_1(100);
1153   1      
1154   1      //  i=addrend;
1155   1      //  FLASH_WriteData(i,0X2F00+9);
1156   1      //  Delay_us_1(100);
1157   1        
1158   1        Flash_EraseBlock(0x2F80);
1159   1        Delay_us_1(10000);
1160   1        FLASH_WriteData(0,0x2F80+0);
1161   1        
1162   1        EA=1;       //-20200927
1163   1      
1164   1      }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          10/13/2020 14:51:02 PAGE 20  

1165          
1166          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1913    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     31    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      48
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

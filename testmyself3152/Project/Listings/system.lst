C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\Objects\system.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\system.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\s
                    -ystem.lst) TABS(2) OBJECT(.\Objects\system.obj)

line level    source

   1          /****************************************Copyright (c)*************************
   2          **                               版权所有 (C), 2015-2017, 涂鸦科技
   3          **
   4          **                                 http://www.tuya.com
   5          **
   6          **--------------文件信息-------------------------------------------------------
   7          **文   件   名: system.c
   8          **描        述: bluetooth数据处理函数
   9          **使 用 说 明 : 用户无需关心该文件实现内容
  10          **
  11          **
  12          **--------------当前版本修订---------------------------------------------------
  13          ** 版  本: v1.0
  14          ** 日　期: 2017年5月3日
  15          ** 描　述: 1:创建涂鸦bluetooth对接MCU_SDK
  16          **
  17          **-----------------------------------------------------------------------------
  18          ******************************************************************************/
  19          #define SYSTEM_GLOBAL
  20          
  21          #include "bluetooth.h"
  22          //
  23          //
  24          void savevar(void);
  25          extern const DOWNLOAD_CMD_S xdata download_cmd[];
  26          
  27          /*****************************************************************************
  28          函数名称 : set_bt_uart_byte
  29          功能描述 : 写bt_uart字节
  30          输入参数 : dest:缓存区其实地址;
  31                     byte:写入字节值
  32          返回参数 : 写入完成后的总长度
  33          *****************************************************************************/
  34          unsigned short set_bt_uart_byte(unsigned short dest, unsigned char byte)
  35          {
  36   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  37   1        
  38   1        *obj = byte;
  39   1        dest += 1;
  40   1        
  41   1        return dest;
  42   1      }
  43          /*****************************************************************************
  44          函数名称 : set_bt_uart_buffer
  45          功能描述 : 写bt_uart_buffer
  46          输入参数 : dest:目标地址
  47                     src:源地址
  48                     len:数据长度
  49          返回参数 : 无
  50          *****************************************************************************/
  51          unsigned short set_bt_uart_buffer(unsigned short dest, unsigned char *src, unsigned short len)
  52          {
  53   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  54   1        
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 2   

  55   1        my_memcpy(obj,src,len);
  56   1        
  57   1        dest += len;
  58   1        return dest;
  59   1      }
  60          /*****************************************************************************
  61          函数名称 : bt_uart_write_data
  62          功能描述 : 向bt uart写入连续数据
  63          输入参数 : in:发送缓存指针
  64                     len:数据发送长度
  65          返回参数 : 无
  66          *****************************************************************************/
  67          static void bt_uart_write_data(unsigned char *in, unsigned short len)
  68          {
  69   1        if((NULL == in) || (0 == len))
  70   1        {
  71   2          return;
  72   2        }
  73   1        
  74   1        while(len --)
  75   1        {
  76   2          uart_transmit_output(*in);
  77   2          in ++;
  78   2        }
  79   1      }
  80          /*****************************************************************************
  81          函数名称 : get_check_sum
  82          功能描述 : 计算校验和
  83          输入参数 : pack:数据源指针
  84                     pack_len:计算校验和长度
  85          返回参数 : 校验和
  86          *****************************************************************************/
  87          unsigned char get_check_sum(unsigned char *pack, unsigned short pack_len)
  88          {
  89   1        unsigned short i;
  90   1        unsigned char check_sum = 0;
  91   1        
  92   1        for(i = 0; i < pack_len; i ++)
  93   1        {
  94   2          check_sum += *pack ++;
  95   2        }
  96   1        
  97   1        return check_sum;
  98   1      }
  99          /*****************************************************************************
 100          函数名称 : bt_uart_write_frame
 101          功能描述 : 向bt串口发送一帧数据
 102          输入参数 : fr_type:帧类型
 103                     len:数据长度
 104          返回参数 : 无
 105          *****************************************************************************/
 106          void bt_uart_write_frame(unsigned char fr_type, unsigned short len)
 107          {
 108   1        unsigned char check_sum = 0;
 109   1        
 110   1        bt_uart_tx_buf[HEAD_FIRST] = 0x55;
 111   1        bt_uart_tx_buf[HEAD_SECOND] = 0xaa;
 112   1        bt_uart_tx_buf[PROTOCOL_VERSION] = 0x00;
 113   1        bt_uart_tx_buf[FRAME_TYPE] = fr_type;
 114   1        bt_uart_tx_buf[LENGTH_HIGH] = len >> 8;
 115   1        bt_uart_tx_buf[LENGTH_LOW] = len & 0xff;
 116   1        
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 3   

 117   1        len += PROTOCOL_HEAD;
 118   1        check_sum = get_check_sum((unsigned char *)bt_uart_tx_buf, len - 1);
 119   1        bt_uart_tx_buf[len - 1] = check_sum;
 120   1        //
 121   1        bt_uart_write_data((unsigned char *)bt_uart_tx_buf, len);
 122   1      }
 123          /*****************************************************************************
 124          函数名称 : heat_beat_check
 125          功能描述 : 心跳包检测
 126          输入参数 : 无
 127          返回参数 : 无
 128          *****************************************************************************/
 129          static void heat_beat_check(void)
 130          {
 131   1        unsigned char length = 0;
 132   1        static unsigned char mcu_reset_state = FALSE;
 133   1        
 134   1        if(FALSE == mcu_reset_state)
 135   1        {
 136   2          length = set_bt_uart_byte(length,FALSE);
 137   2          mcu_reset_state = TRUE;
 138   2        }
 139   1        else
 140   1        {
 141   2          length = set_bt_uart_byte(length,TRUE);
 142   2        }
 143   1        
 144   1        bt_uart_write_frame(HEAT_BEAT_CMD, length);
 145   1      }
 146          /*****************************************************************************
 147          函数名称  : product_info_update
 148          功能描述  : 产品信息上传
 149          输入参数 : 无
 150          返回参数 : 无
 151          *****************************************************************************/
 152          static void product_info_update(void)
 153          {
 154   1        unsigned char length = 0;
 155   1        
 156   1        length = set_bt_uart_buffer(length,(unsigned char *)PRODUCT_KEY,my_strlen((unsigned char *)PRODUCT_KEY))
             -;
 157   1        length = set_bt_uart_buffer(length,(unsigned char *)MCU_VER,my_strlen((unsigned char *)MCU_VER));
 158   1        
 159   1        bt_uart_write_frame(PRODUCT_INFO_CMD, length);
 160   1      }
 161          /*****************************************************************************
 162          函数名称 : get_mcu_bt_mode
 163          功能描述 : 查询mcu和bt的工作模式
 164          输入参数 : 无
 165          返回参数 : 无
 166          *****************************************************************************/
 167          static void get_mcu_bt_mode(void)
 168          {
 169   1        unsigned char length = 0;
 170   1        
 171   1      #ifdef BT_CONTROL_SELF_MODE                                   //模块自处理
                length = set_bt_uart_byte(length, BT_STATE_KEY);
                length = set_bt_uart_byte(length, BT_RESERT_KEY);
              #else                                                           
 175   1        //无需处理数据
 176   1      #endif
 177   1        
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 4   

 178   1        bt_uart_write_frame(WORK_MODE_CMD, length);
 179   1      }
 180          /*****************************************************************************
 181          函数名称 : get_update_dpid_index
 182          功能描述 : 或许制定DPID在数组中的序号
 183          输入参数 : dpid:dpid
 184          返回参数 : index:dp序号
 185          *****************************************************************************/
 186          static unsigned char get_dowmload_dpid_index(unsigned char dpid)
 187          {
 188   1        unsigned char index;
 189   1        unsigned char total = get_download_cmd_total();
 190   1        
 191   1        for(index = 0; index < total; index ++)
 192   1        {
 193   2          if(download_cmd[index].dp_id == dpid)
 194   2          {
 195   3            break;
 196   3          }
 197   2        }
 198   1        
 199   1        return index;
 200   1      }
 201          /*****************************************************************************
 202          函数名称 : data_point_handle
 203          功能描述 : 下发数据处理
 204          输入参数 : value:下发数据源指针
 205          返回参数 : ret:返回数据处理结果
 206          *****************************************************************************/
 207          static unsigned char data_point_handle(const unsigned char value[])
 208          {
 209   1        unsigned char dp_id,index;
 210   1        unsigned char dp_type;
 211   1        unsigned char ret;
 212   1        unsigned short dp_len;
 213   1        
 214   1        dp_id = value[0];
 215   1        dp_type = value[1];
 216   1        dp_len = value[2] * 0x100;
 217   1        dp_len += value[3];
 218   1        
 219   1        index = get_dowmload_dpid_index(dp_id);
 220   1      
 221   1        if(dp_type != download_cmd[index].dp_type)
 222   1        {
 223   2          //错误提示
 224   2          return FALSE;
 225   2        }
 226   1        else
 227   1        {
 228   2          ret = dp_download_handle(dp_id,value + 4,dp_len);
 229   2        }
 230   1        
 231   1        return ret;
 232   1      }
 233          /*****************************************************************************
 234          函数名称 : data_handle
 235          功能描述 : 数据帧处理
 236          输入参数 : offset:数据起始位
 237          返回参数 : 无
 238          *****************************************************************************/
 239          void data_handle(unsigned short offset)
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 5   

 240          {
 241   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
                unsigned char *firmware_addr;
                static unsigned long firm_length;                                             //MCU升级文件长度
                static unsigned char firm_update_flag;                                        //MCU升级标志
                unsigned long dp_len;
              #else
 247   1        unsigned short dp_len;
 248   1      #endif
 249   1        
 250   1        unsigned char ret;
 251   1        unsigned short i,total_len;
 252   1        unsigned char cmd_type = bt_uart_rx_buf[offset + FRAME_TYPE];
 253   1        
 254   1        switch(cmd_type)
 255   1        {
 256   2        case HEAT_BEAT_CMD:                                   //心跳包
 257   2          heat_beat_check();
 258   2          break;
 259   2          
 260   2        case PRODUCT_INFO_CMD:                                //产品信息
 261   2          product_info_update();
 262   2          break;
 263   2          
 264   2        case WORK_MODE_CMD:                                   //查询MCU设定的模块工作模式
 265   2          get_mcu_bt_mode();
 266   2          break;
 267   2          
 268   2      #ifndef BT_CONTROL_SELF_MODE
 269   2        case BT_STATE_CMD:                                  //bt工作状态  
 270   2          bt_work_state = bt_uart_rx_buf[offset + DATA_START];
 271   2          bt_uart_write_frame(BT_STATE_CMD,0);
 272   2          break;
 273   2      
 274   2        case BT_RESET_CMD:                                  //重置bt(bt返回成功)
 275   2          reset_bt_flag = RESET_BT_SUCCESS;
 276   2          break;
 277   2      #endif
 278   2          
 279   2        case DATA_QUERT_CMD:                                  //命令下发
 280   2          total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
 281   2          total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
 282   2          
 283   2          for(i = 0;i < total_len;)
 284   2          {
 285   3            dp_len = bt_uart_rx_buf[offset + DATA_START + i + 2] * 0x100;
 286   3            dp_len += bt_uart_rx_buf[offset + DATA_START + i + 3];
 287   3            //
 288   3            ret = data_point_handle((unsigned char *)bt_uart_rx_buf + offset + DATA_START + i);
 289   3            
 290   3            if(SUCCESS == ret)
 291   3            {
 292   4              //成功提示
 293   4            }
 294   3            else
 295   3            {
 296   4              //错误提示
 297   4            }
 298   3            
 299   3            i += (dp_len + 4);
 300   3          }
 301   2          
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 6   

 302   2          break;
 303   2          
 304   2        case STATE_QUERY_CMD:                                 //状态查询
 305   2          all_data_update();                               
 306   2          break;
 307   2          
 308   2      #ifdef SUPPORT_MCU_FIRM_UPDATE
                case UPDATE_START_CMD:                                //升级开始
                  firm_length = bt_uart_rx_buf[offset + DATA_START];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 1];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 2];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 3];
                  //
                  bt_uart_write_frame(UPDATE_START_CMD,0);
                  firm_update_flag = UPDATE_START_CMD;
                   break;
                  
                case UPDATE_TRANS_CMD:                                //升级传输
                  if(firm_update_flag == UPDATE_START_CMD)
                  {
                    //停止一切数据上报
                    stop_update_flag = ENABLE;                                                 
                    
                    total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
                    total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
                    
                    dp_len = bt_uart_rx_buf[offset + DATA_START];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 1];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 2];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 3];
                    
                    firmware_addr = bt_uart_rx_buf + offset + DATA_START + 4;
                    if((total_len == 4) && (dp_len == firm_length))
                    {
                      //最后一包
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
                      
                      firm_update_flag = 0;
                    }
                    else if((total_len - 4) <= FIRM_UPDATA_SIZE)
                    {
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
                    }
                    else
                    {
                      firm_update_flag = 0;
                      ret = ERROR;
                    }
                    
                    if(ret == SUCCESS)
                    {
                      bt_uart_write_frame(UPDATE_TRANS_CMD,0);
                    }
                    //恢复一切数据上报
                    stop_update_flag = DISABLE;    
                  }
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/12/2020 09:44:13 PAGE 7   

                  break;
              #endif      
 366   2      
 367   2        default:
 368   2          break;
 369   2        }
 370   1      }
 371          /*****************************************************************************
 372          函数名称 : get_queue_total_data
 373          功能描述 : 读取队列内数据
 374          输入参数 : 无
 375          返回参数 : 无
 376          *****************************************************************************/
 377          unsigned char get_queue_total_data(void)
 378          {
 379   1        if(queue_in != queue_out)
 380   1          return 1;
 381   1        else
 382   1          return 0;
 383   1      }
 384          /*****************************************************************************
 385          函数名称 : Queue_Read_Byte
 386          功能描述 : 读取队列1字节数据
 387          输入参数 : 无
 388          返回参数 : 无
 389          *****************************************************************************/
 390          unsigned char Queue_Read_Byte(void)
 391          {
 392   1        unsigned char value;
 393   1        
 394   1        if(queue_out != queue_in)
 395   1        {
 396   2          //有数据
 397   2          if(queue_out >= (unsigned char *)(bt_queue_buf + sizeof(bt_queue_buf)))
 398   2          {
 399   3            //数据已经到末尾
 400   3            queue_out = (unsigned char *)(bt_queue_buf);
 401   3          }
 402   2          
 403   2          value = *queue_out ++;   
 404   2        }
 405   1        
 406   1        return value;
 407   1      }
 408          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    851    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =     89    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      37
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

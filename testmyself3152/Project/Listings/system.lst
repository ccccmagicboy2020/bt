C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\Objects\system.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\system.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\s
                    -ystem.lst) TABS(2) OBJECT(.\Objects\system.obj)

line level    source

   1          /****************************************Copyright (c)*************************
   2          **                               版权所有 (C), 2015-2017, 涂鸦科技
   3          **
   4          **                                 http://www.tuya.com
   5          **
   6          **--------------文件信息-------------------------------------------------------
   7          **文   件   名: system.c
   8          **描        述: bluetooth数据处理函数
   9          **使 用 说 明 : 用户无需关心该文件实现内容
  10          **
  11          **
  12          **--------------当前版本修订---------------------------------------------------
  13          ** 版  本: v1.0
  14          ** 日　期: 2017年5月3日
  15          ** 描　述: 1:创建涂鸦bluetooth对接MCU_SDK
  16          **
  17          **-----------------------------------------------------------------------------
  18          ******************************************************************************/
  19          #define SYSTEM_GLOBAL
  20          
  21          #include "bluetooth.h"
  22          //
  23          //
  24          /*
  25          extern u8 idata groupaddr1 ;
  26          extern u8 idata groupaddr2 ;
  27          extern u8 idata groupaddr3 ;
  28          extern u8 idata groupaddr4 ;
  29          extern u8 idata groupaddr5 ;
  30          extern u8 idata groupaddr6 ;
  31          extern u8 idata groupaddr7 ;
  32          extern u8 idata groupaddr8 ;
  33          */
  34          
  35          extern u16 idata groupaddr[8];
  36          
  37          void savevar(void);
  38          extern const DOWNLOAD_CMD_S xdata download_cmd[];
  39          
  40          /*****************************************************************************
  41          函数名称 : set_bt_uart_byte
  42          功能描述 : 写bt_uart字节
  43          输入参数 : dest:缓存区其实地址;
  44                     byte:写入字节值
  45          返回参数 : 写入完成后的总长度
  46          *****************************************************************************/
  47          unsigned short set_bt_uart_byte(unsigned short dest, unsigned char byte)
  48          {
  49   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  50   1        
  51   1        *obj = byte;
  52   1        dest += 1;
  53   1        
  54   1        return dest;
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 2   

  55   1      }
  56          /*****************************************************************************
  57          函数名称 : set_bt_uart_buffer
  58          功能描述 : 写bt_uart_buffer
  59          输入参数 : dest:目标地址
  60                     src:源地址
  61                     len:数据长度
  62          返回参数 : 无
  63          *****************************************************************************/
  64          unsigned short set_bt_uart_buffer(unsigned short dest, unsigned char *src, unsigned short len)
  65          {
  66   1        unsigned char *obj = (unsigned char *)bt_uart_tx_buf + DATA_START + dest;
  67   1        
  68   1        my_memcpy(obj,src,len);
  69   1        
  70   1        dest += len;
  71   1        return dest;
  72   1      }
  73          /*****************************************************************************
  74          函数名称 : bt_uart_write_data
  75          功能描述 : 向bt uart写入连续数据
  76          输入参数 : in:发送缓存指针
  77                     len:数据发送长度
  78          返回参数 : 无
  79          *****************************************************************************/
  80          static void bt_uart_write_data(unsigned char *in, unsigned short len)
  81          {
  82   1        if((NULL == in) || (0 == len))
  83   1        {
  84   2          return;
  85   2        }
  86   1        
  87   1        while(len --)
  88   1        {
  89   2          uart_transmit_output(*in);
  90   2          in ++;
  91   2        }
  92   1      }
  93          /*****************************************************************************
  94          函数名称 : get_check_sum
  95          功能描述 : 计算校验和
  96          输入参数 : pack:数据源指针
  97                     pack_len:计算校验和长度
  98          返回参数 : 校验和
  99          *****************************************************************************/
 100          unsigned char get_check_sum(unsigned char *pack, unsigned short pack_len)
 101          {
 102   1        unsigned short i;
 103   1        unsigned char check_sum = 0;
 104   1        
 105   1        for(i = 0; i < pack_len; i ++)
 106   1        {
 107   2          check_sum += *pack ++;
 108   2        }
 109   1        
 110   1        return check_sum;
 111   1      }
 112          /*****************************************************************************
 113          函数名称 : bt_uart_write_frame
 114          功能描述 : 向bt串口发送一帧数据
 115          输入参数 : fr_type:帧类型
 116                     len:数据长度
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 3   

 117          返回参数 : 无
 118          *****************************************************************************/
 119          void bt_uart_write_frame(unsigned char fr_type, unsigned short len)
 120          {
 121   1        unsigned char check_sum = 0;
 122   1        
 123   1        bt_uart_tx_buf[HEAD_FIRST] = 0x55;
 124   1        bt_uart_tx_buf[HEAD_SECOND] = 0xaa;
 125   1        bt_uart_tx_buf[PROTOCOL_VERSION] = 0x00;
 126   1        bt_uart_tx_buf[FRAME_TYPE] = fr_type;
 127   1        bt_uart_tx_buf[LENGTH_HIGH] = len >> 8;
 128   1        bt_uart_tx_buf[LENGTH_LOW] = len & 0xff;
 129   1        
 130   1        len += PROTOCOL_HEAD;
 131   1        check_sum = get_check_sum((unsigned char *)bt_uart_tx_buf, len - 1);
 132   1        bt_uart_tx_buf[len - 1] = check_sum;
 133   1        //
 134   1        bt_uart_write_data((unsigned char *)bt_uart_tx_buf, len);
 135   1      }
 136          
 137          
 138          void bt_uart_mesh_write_frame(unsigned char fr_type, unsigned short len)
 139          {
 140   1        unsigned char check_sum = 0;
 141   1      
 142   1      len = len+2;
 143   1      
 144   1      bt_uart_tx_buf[0] = 0x55;
 145   1      bt_uart_tx_buf[1] = 0xaa;
 146   1      bt_uart_tx_buf[2] = 0x00;
 147   1      bt_uart_tx_buf[3] = fr_type;
 148   1      
 149   1      bt_uart_tx_buf[4] = len >> 8;
 150   1      bt_uart_tx_buf[5] = len & 0xff;
 151   1      bt_uart_tx_buf[6] = 0XFF;
 152   1      bt_uart_tx_buf[7] = 0xff;
 153   1      
 154   1      
 155   1      len += PROTOCOL_HEAD;
 156   1      check_sum = get_check_sum((unsigned char *)bt_uart_tx_buf, len - 1);
 157   1      bt_uart_tx_buf[len - 1] = check_sum;
 158   1      //
 159   1      bt_uart_write_data((unsigned char *)bt_uart_tx_buf, len);
 160   1      
 161   1      
 162   1      }
 163          
 164          /*****************************************************************************
 165          函数名称 : heat_beat_check
 166          功能描述 : 心跳包检测
 167          输入参数 : 无
 168          返回参数 : 无
 169          *****************************************************************************/
 170          static void heat_beat_check(void)
 171          {
 172   1        unsigned char length = 0;
 173   1        static unsigned char mcu_reset_state = FALSE;
 174   1        
 175   1        if(FALSE == mcu_reset_state)
 176   1        {
 177   2          length = set_bt_uart_byte(length,FALSE);
 178   2          mcu_reset_state = TRUE;
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 4   

 179   2        }
 180   1        else
 181   1        {
 182   2          length = set_bt_uart_byte(length,TRUE);
 183   2        }
 184   1        
 185   1        bt_uart_write_frame(HEAT_BEAT_CMD, length);
 186   1      }
 187          /*****************************************************************************
 188          函数名称  : product_info_update
 189          功能描述  : 产品信息上传
 190          输入参数 : 无
 191          返回参数 : 无
 192          *****************************************************************************/
 193          static void product_info_update(void)
 194          {
 195   1        unsigned char length = 0;
 196   1        
 197   1        length = set_bt_uart_buffer(length,(unsigned char *)PRODUCT_KEY,my_strlen((unsigned char *)PRODUCT_KEY))
             -;
 198   1        length = set_bt_uart_buffer(length,(unsigned char *)MCU_VER,my_strlen((unsigned char *)MCU_VER));
 199   1        
 200   1        bt_uart_write_frame(PRODUCT_INFO_CMD, length);
 201   1      }
 202          /*****************************************************************************
 203          函数名称 : get_mcu_bt_mode
 204          功能描述 : 查询mcu和bt的工作模式
 205          输入参数 : 无
 206          返回参数 : 无
 207          *****************************************************************************/
 208          static void get_mcu_bt_mode(void)
 209          {
 210   1        unsigned char length = 0;
 211   1        
 212   1      #ifdef BT_CONTROL_SELF_MODE                                   //模块自处理
                length = set_bt_uart_byte(length, BT_STATE_KEY);
                length = set_bt_uart_byte(length, BT_RESERT_KEY);
              #else                                                           
 216   1        //无需处理数据
 217   1      #endif
 218   1        
 219   1        bt_uart_write_frame(WORK_MODE_CMD, length);
 220   1      }
 221          /*****************************************************************************
 222          函数名称 : get_update_dpid_index
 223          功能描述 : 或许制定DPID在数组中的序号
 224          输入参数 : dpid:dpid
 225          返回参数 : index:dp序号
 226          *****************************************************************************/
 227          static unsigned char get_dowmload_dpid_index(unsigned char dpid)
 228          {
 229   1        unsigned char index;
 230   1        unsigned char total = get_download_cmd_total();
 231   1        
 232   1        for(index = 0; index < total; index ++)
 233   1        {
 234   2          if(download_cmd[index].dp_id == dpid)
 235   2          {
 236   3            break;
 237   3          }
 238   2        }
 239   1        
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 5   

 240   1        return index;
 241   1      }
 242          /*****************************************************************************
 243          函数名称 : data_point_handle
 244          功能描述 : 下发数据处理
 245          输入参数 : value:下发数据源指针
 246          返回参数 : ret:返回数据处理结果
 247          *****************************************************************************/
 248          static unsigned char data_point_handle(const unsigned char value[])
 249          {
 250   1        unsigned char dp_id,index;
 251   1        unsigned char dp_type;
 252   1        unsigned char ret;
 253   1        unsigned short dp_len;
 254   1        
 255   1        dp_id = value[0];
 256   1        dp_type = value[1];
 257   1        dp_len = value[2] * 0x100;
 258   1        dp_len += value[3];
 259   1        
 260   1        index = get_dowmload_dpid_index(dp_id);
 261   1      
 262   1        if(dp_type != download_cmd[index].dp_type)
 263   1        {
 264   2          //错误提示
 265   2          return FALSE;
 266   2        }
 267   1        else
 268   1        {
 269   2          ret = dp_download_handle(dp_id,value + 4,dp_len);
 270   2        }
 271   1        
 272   1        return ret;
 273   1      }
 274          /*****************************************************************************
 275          函数名称 : data_handle
 276          功能描述 : 数据帧处理
 277          输入参数 : offset:数据起始位
 278          返回参数 : 无
 279          *****************************************************************************/
 280          void data_handle(unsigned short offset)
 281          {
 282   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
                unsigned char *firmware_addr;
                static unsigned long firm_length;                                             //MCU升级文件长度
                static unsigned char firm_update_flag;                                        //MCU升级标志
                unsigned long dp_len;
              #else
 288   1        unsigned short dp_len;
 289   1      #endif
 290   1        
 291   1        unsigned char ret;
 292   1        unsigned short i,total_len;
 293   1        unsigned char cmd_type = bt_uart_rx_buf[offset + FRAME_TYPE];
 294   1        
 295   1        switch(cmd_type)
 296   1        {
 297   2        case HEAT_BEAT_CMD:                                   //心跳包
 298   2          heat_beat_check();
 299   2          break;
 300   2          
 301   2        case PRODUCT_INFO_CMD:                                //产品信息
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 6   

 302   2          product_info_update();
 303   2          break;
 304   2          
 305   2        case WORK_MODE_CMD:                                   //查询MCU设定的模块工作模式
 306   2          get_mcu_bt_mode();
 307   2          break;
 308   2          
 309   2      #ifndef BT_CONTROL_SELF_MODE
 310   2        case BT_STATE_CMD:                                  //bt工作状态  
 311   2          bt_work_state = bt_uart_rx_buf[offset + DATA_START];
 312   2          bt_uart_write_frame(BT_STATE_CMD,0);
 313   2          break;
 314   2      
 315   2        case BT_RESET_CMD:                                  //重置bt(bt返回成功)
 316   2          reset_bt_flag = RESET_BT_SUCCESS;
 317   2          break;
 318   2      #endif
 319   2          
 320   2        case DATA_QUERT_CMD:                                  //命令下发
 321   2          total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
 322   2          total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
 323   2          
 324   2          for(i = 0;i < total_len;)
 325   2          {
 326   3            dp_len = bt_uart_rx_buf[offset + DATA_START + i + 2] * 0x100;
 327   3            dp_len += bt_uart_rx_buf[offset + DATA_START + i + 3];
 328   3            //
 329   3            ret = data_point_handle((unsigned char *)bt_uart_rx_buf + offset + DATA_START + i);
 330   3            
 331   3            if(SUCCESS == ret)
 332   3            {
 333   4              //成功提示
 334   4              savevar();
 335   4            }
 336   3            else
 337   3            {
 338   4              //错误提示
 339   4            }
 340   3            
 341   3            i += (dp_len + 4);
 342   3          }
 343   2          
 344   2          break;
 345   2        case BT_Check_meshgroup:                                  //查询群组
 346   2          total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
 347   2          total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
 348   2      
 349   2      
 350   2        groupaddr[0] = bt_uart_rx_buf[offset + 7] * 0x100;
 351   2        groupaddr[0] += bt_uart_rx_buf[offset + 8] ;
 352   2      
 353   2        groupaddr[1] = bt_uart_rx_buf[offset + 9] * 0x100;
 354   2        groupaddr[1] += bt_uart_rx_buf[offset + 10] ;
 355   2      
 356   2        groupaddr[2] = bt_uart_rx_buf[offset + 11] * 0x100;
 357   2        groupaddr[2] += bt_uart_rx_buf[offset + 12] ;
 358   2      
 359   2        groupaddr[3] = bt_uart_rx_buf[offset + 13] * 0x100;
 360   2        groupaddr[3] += bt_uart_rx_buf[offset + 14] ;
 361   2      
 362   2        groupaddr[4] = bt_uart_rx_buf[offset + 15] * 0x100;
 363   2        groupaddr[4] += bt_uart_rx_buf[offset + 16] ;
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 7   

 364   2      
 365   2        groupaddr[5] = bt_uart_rx_buf[offset + 17] * 0x100;
 366   2        groupaddr[5] += bt_uart_rx_buf[offset + 18] ;
 367   2      
 368   2        groupaddr[6] = bt_uart_rx_buf[offset + 19] * 0x100;
 369   2        groupaddr[6] += bt_uart_rx_buf[offset + 20] ;
 370   2      
 371   2        groupaddr[7] = bt_uart_rx_buf[offset + 21] * 0x100;
 372   2        groupaddr[7] += bt_uart_rx_buf[offset + 22] ;
 373   2      
 374   2        
 375   2      
 376   2          break;
 377   2        case STATE_QUERY_CMD:                                 //状态查询
 378   2          all_data_update();                               
 379   2          break;
 380   2          
 381   2      #ifdef SUPPORT_MCU_FIRM_UPDATE
                case UPDATE_START_CMD:                                //升级开始
                  firm_length = bt_uart_rx_buf[offset + DATA_START];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 1];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 2];
                  firm_length <<= 8;
                  firm_length |= bt_uart_rx_buf[offset + DATA_START + 3];
                  //
                  bt_uart_write_frame(UPDATE_START_CMD,0);
                  firm_update_flag = UPDATE_START_CMD;
                   break;
                  
                case UPDATE_TRANS_CMD:                                //升级传输
                  if(firm_update_flag == UPDATE_START_CMD)
                  {
                    //停止一切数据上报
                    stop_update_flag = ENABLE;                                                 
                    
                    total_len = bt_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
                    total_len += bt_uart_rx_buf[offset + LENGTH_LOW];
                    
                    dp_len = bt_uart_rx_buf[offset + DATA_START];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 1];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 2];
                    dp_len <<= 8;
                    dp_len |= bt_uart_rx_buf[offset + DATA_START + 3];
                    
                    firmware_addr = bt_uart_rx_buf + offset + DATA_START + 4;
                    if((total_len == 4) && (dp_len == firm_length))
                    {
                      //最后一包
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
                      
                      firm_update_flag = 0;
                    }
                    else if((total_len - 4) <= FIRM_UPDATA_SIZE)
                    {
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
                    }
                    else
                    {
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 8   

                      firm_update_flag = 0;
                      ret = ERROR;
                    }
                    
                    if(ret == SUCCESS)
                    {
                      bt_uart_write_frame(UPDATE_TRANS_CMD,0);
                    }
                    //恢复一切数据上报
                    stop_update_flag = DISABLE;    
                  }
                  break;
              #endif      
 439   2      
 440   2        default:
 441   2          break;
 442   2        }
 443   1      }
 444          /*****************************************************************************
 445          函数名称 : get_queue_total_data
 446          功能描述 : 读取队列内数据
 447          输入参数 : 无
 448          返回参数 : 无
 449          *****************************************************************************/
 450          unsigned char get_queue_total_data(void)
 451          {
 452   1        if(queue_in != queue_out)
 453   1          return 1;
 454   1        else
 455   1          return 0;
 456   1      }
 457          /*****************************************************************************
 458          函数名称 : Queue_Read_Byte
 459          功能描述 : 读取队列1字节数据
 460          输入参数 : 无
 461          返回参数 : 无
 462          *****************************************************************************/
 463          unsigned char Queue_Read_Byte(void)
 464          {
 465   1        unsigned char value;
 466   1        
 467   1        if(queue_out != queue_in)
 468   1        {
 469   2          //有数据
 470   2          if(queue_out >= (unsigned char *)(bt_queue_buf + sizeof(bt_queue_buf)))
 471   2          {
 472   3            //数据已经到末尾
 473   3            queue_out = (unsigned char *)(bt_queue_buf);
 474   3          }
 475   2          
 476   2          value = *queue_out ++;   
 477   2        }
 478   1        
 479   1        return value;
 480   1      }
 481          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1346    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =     89    ----
C51 COMPILER V9.52.0.0   SYSTEM                                                            10/14/2020 09:07:16 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HC_MCU_XBR
OBJECT MODULE PLACED IN .\Objects\HC-MCU-XBR.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\HC-MCU-XBR.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\HC-MCU-XBR.lst) TABS(2) OBJECT(.\Objects\HC-MCU-XBR.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89S003F4.h"
   3          //#include "Mcu_api.h"
   4          #include "bluetooth.h"
   5          
   6          #define V12
   7          
   8          
   9          
  10          //#define  VERSION  0X21
  11          
  12          #define  TH_LOW   30000
  13          #define  TH_HIGH  4000000
  14          
  15          #define  TH_DEF   40000
  16            
  17          //ÔÊÐíÔëÉùÖµÆ«²î·¶Î§
  18          #define  MAX_DELTA0  20000
  19          #define  MAX_DELTA1  60000
  20          
  21          #define  MAX_DELAY  1800
  22          //×î´óÑÓÊ±ÃëÊý
  23          
  24          //¸Ð¹âÃÅÏÞ-30¶ÔÓ¦8LUX×óÓÒµÄADÖµ,ÉèÖÃÎª255±íÊ¾²»¼ì²â¸Ð¹â
  25          #define  LIGHT_TH0 255
  26          //30
  27          
  28          //Ò»¸ö¼ì²âÖÜÆÚÎª0.25Ãë
  29          //#define DELAY_NUM 20
  30          
  31          
  32          //#define LIGHT_ON P0_6=0
  33          //#define LIGHT_OFF P0_6=1
  34          
  35          //void Delay_2us(u16 Cnt);    //ÑÓÊ±º¯Êý
  36          
  37          // bit Timer1_FLAG;
  38          // bit Time_10mS_FLAG;
  39          // bit Time_100mS_FLAG;
  40          // bit Time_200mS_FLAG;
  41          // bit Time_500mS_FLAG;
  42          // bit Time_1S_FLAG;
  43          // bit Time_10S_FLAG;
  44          // bit Time_1Min_FLAG;
  45          // bit Time_1H_FLAG;
  46          
  47          volatile ulong Timer_Counter=0;
  48          
  49           //u8 Uart1_RX_Buff[10] = {0};           //ÓÃÓÚ´æ·ÅUART1½ÓÊÕÊý¾Ý
  50           //u8 Uart1_RX_Cnt = 0;                //UART1½ÓÊÕ¼ÆÊý
  51           //u8 Uart1_TX_Buff[20] = {0};           //ÓÃÓÚ´æ·ÅUART1·¢ËÍÊý¾Ý
  52           //u8 Uart1_TX_Cnt = 0;                //UART1·¢ËÍ¼ÆÊý
  53           
  54          // u16 AN1_Data = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 2   

  55          // u16 AN7_Data = 0;
  56          // u8 Uart_Cnt = 0;
  57          
  58          
  59            u8 xdata SUM1_counter=0,SUM1_num=64,SUM0_num=12;
  60            ulong xdata SUM1=0,SUM0=0,SUM=0,ALL_SUM1=0,SUM10=0,SUM16=0,SUM01,SUM2;
  61            u16   xdata times=0,start_times=1;
  62            ulong  xdata TH,MAX_DELTA;
  63            u8  xdata alarm_times=0,stop_times=0;
  64          
  65            uint  xdata average,LIGHT=0,LIGHT_off=0;
  66            u8  xdata light_ad,light_ad0,check_light_times=8,calc_average_times=0,check_sum,send_byte;
  67            u8  xdata LIGHT_TH;
  68            u16  xdata DELAY_NUM;
  69            u8 xdata lowlightDELAY_NUM;
  70            u8  xdata RXnum=0;
  71            u8 while_1flag = 0;
  72            u8 while_2flag = 0;
  73            u8 xdata  SWITCHflag = 0;
  74            u8 xdata  SWITCHflag2 = 0;
  75            u8 xdata  SWITCHfXBR = 1;
  76            u8      xdata lightvalue = 10;
  77            u8 xdata switchcnt = 0;
  78            u8 xdata slowchcnt = 10;
  79             u8 xdata resetbtcnt = 0;
  80             u8 xdata XRBoffbrightvalue = 0;
  81             volatile u16 xdata lowlight1mincount = 0;
  82             volatile u8 xdata  lowlight1minflag =0;
  83            volatile u16 idata light1scount  = 0;
  84            volatile u16 idata light1sflag = 0;
  85             u8 xdata addr = 0;
  86             u8 xdata devgroup = 0;
  87             u8 xdata addrend=0;
  88             u16 idata groupaddr[8] = {0};
  89             u8 idata check_group_flag = 0;
  90             u8 idata check_group_count = 0;
  91             /*
  92             u8 idata groupaddr2 = 0;
  93             u8 idata groupaddr3 = 0;
  94             u8 idata groupaddr4 = 0;
  95             u8 idata groupaddr5 = 0;
  96             u8 idata groupaddr6 = 0;
  97             u8 idata groupaddr7 = 0;
  98             u8 idata groupaddr8 = 0;
  99             */
 100           unsigned char PWM3init(unsigned char ab);
 101          void Flash_EraseBlock(unsigned int fui_Address);//ÉÈÇø²Á³ý
 102          //void FLASH_WriteData(unsigned char fui_Address, unsigned int fuc_SaveData);//Ð´ÈëÒ»¸öÊý¾Ý
 103          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);
 104          //void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//Ð´È
             -ëÈÎÒâ³¤¶ÈÊý¾Ý
 105          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//¶ÁÈ¡ÈÎ
             -Òâ³¤¶ÈÊý¾Ý
 106          
 107          //unsigned char guc_Write_a[5] = {0}; //Ð´ÈëÊý¾Ý
 108          unsigned char xdata guc_Read_a[10] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
 109          unsigned char xdata guc_Read_a1[1] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
 110          // unsigned char guc_Uartflag = 0;            //·¢ËÍ±êÖ¾Î»
 111          // unsigned char guc_Uartcnt = 0;           //·¢ËÍ¼ÆÊý
 112          // unsigned char guc_Uartbuf_a[2] = {0x00}; //»º´æÊý×é
 113          
 114          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 3   

 115          {
 116   1        while(fuc_Length--)
 117   1        *(fucp_SaveArr++)=*((unsigned char code *)(fui_Address++));//¶ÁÈ¡Êý¾Ý
 118   1      }
 119          
 120          void Delay_us(uint q)
 121          {
 122   1        uint j;
 123   1        for(j=0;j<q;j++)
 124   1        {
 125   2            ;
 126   2        }
 127   1      }
 128          
 129          void Delay_ms(uint t)
 130          {
 131   1        Timer_Counter=0;
 132   1        while(Timer_Counter<t)
 133   1        {
 134   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 135   2        }
 136   1        
 137   1      }
 138          
 139          void Delay_us_1(uint q1)
 140          {
 141   1        uint j;
 142   1        for(j=0;j<q1;j++)
 143   1        {
 144   2            ;
 145   2        }
 146   1      }
 147          
 148          
 149          
 150          // void Delay_ms(uint t)
 151          // {
 152          //  for(;t>0;t--)
 153          //  {
 154          //    Delay_us_1(1000);
 155          //    WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 156          //  }
 157          // }
 158          
 159          /***************************************************************************************
 160            * @ËµÃ÷   ÏµÍ³³õÊ¼»¯º¯Êý
 161            * @²ÎÊý   ÎÞ
 162            * @·µ»ØÖµ ÎÞ
 163            * @×¢     ÎÞ
 164          ***************************************************************************************/
 165          void InitSYS()
 166          {
 167   1        /********************************ÏµÍ³ÆµÂÊ³õÊ¼»¯***************************************/
 168   1        
 169   1        CLKSWR = 0x51;                     //Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
 170   1        CLKDIV = 0x01;                     //Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz 
 171   1        FREQ_CLK = 0x10;                   //IAPÆµÂÊ
 172   1        
 173   1        /**********************************µÍÑ¹¸´Î»³õÊ¼»¯**************************************/
 174   1        
 175   1      //  BORC = 0xC0;                       //Ê¹ÄÜµÍÑ¹¸´Î»1.8V£¬´øÏû¶¶Ê¹ÄÜ
 176   1      //  BORDBC = 0x01;                     //Ïû¶¶Ê±¼äBORDBC*8TCPU+2TCPU
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 4   

 177   1        
 178   1        /***********************************¿´ÃÅ¿Ú³õÊ¼»¯***************************************/
 179   1        WDTC = 0x5F;                       //ÔÊÐíWDT¸´Î»£¬¿ÕÏÐÄ£Ê½ÏÂ½ûÖ¹WDT£¬Ñ¡Ôñ1024·ÖÆµ£¨ÄÚ²¿µÍÆµÊ±ÖÓ44K£©
 180   1        WDTCCR = 0X20;  //0X20/44 =0.73Ãë           //0xFF;  //Òç³öÊ±¼äÔ¼6Ãë
 181   1        //Òç³ö¼ÆËãÊ±¼ä=£¨WDT·ÖÆµÏµÊý*£¨WDTCCR+1£©£©/ÄÚ²¿µÍÆµRCÆµÂÊ
 182   1      }
 183          
 184          /***************************************************************************************
 185            * @ËµÃ÷   ¶¨Ê±Æ÷³õÊ¼»¯º¯Êý
 186            * @²ÎÊý   ÎÞ
 187            * @·µ»ØÖµ ÎÞ
 188            * @×¢     ÎÞ
 189          ***************************************************************************************/
 190          void Timer_Init()
 191          {
 192   1        /**********************************TIM1ÅäÖÃ³õÊ¼»¯**************************************/
 193   1        TCON1 = 0x00;             //T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 194   1        TMOD = 0x01;              //T1-16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷,T0-16Î»¶¨Ê±Æ÷
 195   1      
 196   1        //Tim1¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊý))
 197   1        //        = 1333 / (16000000 / 12)
 198   1        //        = 1 ms
 199   1      
 200   1        //¶¨Ê±1ms
 201   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊý)))
 202   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 203   1        //      = 65536 - 1333
 204   1        //      = 0xFACB
 205   1        
 206   1        TH1 = 0xFA;
 207   1        TL1 = 0xCB;
 208   1        IE |= 0x08;               //´ò¿ªT1ÖÐ¶Ï
 209   1        TCON |= 0x40;             //Ê¹ÄÜT1
 210   1          
 211   1        
 212   1          
 213   1        TH0 = 0xCB;
 214   1        TL0 = 0xEB;               //T0¶¨Ê±Ê±¼ä10ms
 215   1        
 216   1        TCON |= 0x10;             //Ê¹ÄÜT0
 217   1      }
 218          
 219          /***************************************************************************************
 220            * @ËµÃ÷   UART1³õÊ¼»¯º¯Êý
 221            * @²ÎÊý   ÎÞ
 222            * @·µ»ØÖµ ÎÞ
 223            * @×¢     ÎÞ
 224          ***************************************************************************************/
 225          void UART1_Init()
 226          {
 227   1        /**********************************UARTÅäÖÃ³õÊ¼»¯**************************************/
 228   1        P2M0 = P2M0&0xF0|0x08;              //P20ÉèÖÃÎªÍÆÍìÊä³ö
 229   1        P0M2 = P0M2&0xF0|0x02;              //P04ÉèÖÃÎªÉÏÀ­ÊäÈë
 230   1        P0_4 = 1;
 231   1        TXD_MAP = 0x20;                     //TXDÓ³ÉäP20
 232   1        RXD_MAP = 0x04;                     //RXDÓ³ÉäP04    
 233   1        T4CON = 0x06;                       //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
 234   1        
 235   1        //²¨ÌØÂÊ¼ÆËã
 236   1        //²¨ÌØÂÊ = 1/16 * (T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) / (65536 - 0xFF98)
 237   1        //       = 1/16 * ((16000000 / 1) / 104)
 238   1        //     = 9615.38(Îó²î0.16%)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 5   

 239   1      
 240   1        //²¨ÌØÂÊ9600
 241   1        //·´ÍÆ³õÖµ = (65536 - ((T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) * (1 / 16)) / ²¨ÌØÂÊ)
 242   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
 243   1        //       = (65536 - 104.167)
 244   1        //         = FF98
 245   1        //0xFF98->9600
 246   1        //0xFFCC->19200
 247   1        //0xFFEF->57600
 248   1        
 249   1        
 250   1        TH4 = 0xFF;
 251   1        TL4 = 0x98; //²¨ÌØÂÊ9600    //0xEE;       //²¨ÌØÂÊ56000
 252   1        SCON2 = 0x02;                        //8Î»UART£¬²¨ÌØÂÊ¿É±ä
 253   1        SCON = 0x10;                         //ÔÊÐí´®ÐÐ½ÓÊÕ
 254   1        IE |= 0X10;                          //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
 255   1        //EA = 1;                              //Ê¹ÄÜ×ÜÖÐ¶Ï
 256   1      }
 257          
 258          /***************************************************************************************
 259            * @ËµÃ÷   ADC³õÊ¼»¯º¯Êý
 260            * @²ÎÊý   ÎÞ
 261            * @·µ»ØÖµ ÎÞ
 262            * @×¢     ÎÞ
 263          ***************************************************************************************/
 264          void ADC_Init()
 265          {
 266   1        
 267   1        ADCC0 |= 0x03;            //²Î¿¼Ô´ÎªÄÚ²¿2V
 268   1        ADCC0 |= 0x80;              //´ò¿ªADC×ª»»µçÔ´
 269   1        Delay_us(20);           //ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 270   1        ADCC1 = 0x01;             //Ñ¡ÔñÍâ²¿Í¨µÀ1
 271   1        ADCC2 = 0x4B;         //8·ÖÆµ   //×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ-1MHZ//0X4B-8·ÖÆµ//0X49-4·ÖÆµ
 272   1      }
 273          
 274          /***************************************************************************************
 275            * @ËµÃ÷   IO¿Ú³õÊ¼»¯º¯Êý
 276            * @²ÎÊý   ÎÞ
 277            * @·µ»ØÖµ ÎÞ
 278            * @×¢     ÎÞ
 279          ***************************************************************************************/
 280          void GPIO_Init()
 281          {
 282   1        //P0M0·Ö¸ß4Î»ÓëµÍ4Î»£¬µÍ4Î»¿ØÖÆP00ÊäÈëÊä³ö£¬¸ß4Î»¿ØÖÆP01ÊäÈëÊä³ö£¬ÆäËûÒÔ´ËÀàÍÆ
 283   1        //P0M1¸ß4¿ØÖÆP03£¬µÍ4¿ØÖÆP02
 284   1        //P1M2¸ß4¿ØÖÆP15£¬µÍ4¿ØÖÆP14
 285   1        
 286   1      //  P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
 287   1      //  P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 288   1      //  P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 289   1      //  P0M3 = P0M3&0xF0|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
 290   1        
 291   1        #ifdef V11
                
                P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
                //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
              //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
                
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 6   

                P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
                
                #endif
 306   1        
 307   1        #ifdef V10
                
                P0M0 = P0M0&0xF0|0x08;          //P00
                
                P0M0 = P0M0&0x0F|0x30;          //P01
                P0M3 = P0M3&0x0F|0x30;          //P07
              //  P0M0 = P0M0&0x0F|0x80;          //P01
                
                P0M3 = P0M3&0xF0|0x08;          //P06
                
                #endif
 318   1        
 319   1        #ifdef V12
 320   1        
 321   1        P1M0 = P1M0&0xF0|0x08;          //P10ÉèÖÃÎªÍÆÍìÊä³ö
 322   1        
 323   1        P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 324   1        
 325   1        P2M1 = P2M1&0xF0|0x03;          //P22ÉèÖÃÎªÄ£ÄâÊäÈë 
 326   1        
 327   1        //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 328   1      //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
 329   1        
 330   1        //P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
 331   1        
 332   1        //P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
 333   1        
 334   1      //  P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
 335   1        
 336   1        #endif    
 337   1        
 338   1        
 339   1      }
 340          
 341          // u16 Read_ADC(u8 Channel)
 342          // {
 343          //  u16 ADC_Temp;
 344          //  ADCC1 = Channel;              //Ñ¡ÔñÍâ²¿Í¨µÀ1
 345          //   ADCC0 |= 0x40;         //Æô¶¯ADC×ª»»
 346          //  while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 347          //  ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 348          //  ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 349          //  return ADC_Temp;
 350          // }
 351          
 352          /***************************************************************************************
 353            * @ËµÃ÷   ÏµÍ³Ê±ÖÓ¼ÆÊýº¯Êý
 354            * @²ÎÊý   ÎÞ
 355            * @·µ»ØÖµ ÎÞ
 356            * @×¢     ÎÞ
 357          ***************************************************************************************/
 358          /*
 359          void System_Time_Cnt(void)
 360          {
 361              static u32 Timer1Count1 = 0;
 362              static u8 Timer1Count2 = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 7   

 363              u32 Tampe = 1;
 364              if(Timer1_FLAG)              //1ms
 365              {
 366                  Timer1_FLAG = 0;
 367                  Timer1Count1 ++;
 368                  Tampe = Timer1Count1 % 10;
 369                  if(Tampe == 0)
 370                      Time_10mS_FLAG = 1;
 371                  Tampe = Timer1Count1 % 100;
 372                  if(Tampe == 0)
 373                      Time_100mS_FLAG = 1;
 374                  Tampe = Timer1Count1 % 200;
 375                  if(Tampe == 0)
 376                      Time_200mS_FLAG = 1;
 377                  Tampe = Timer1Count1 % 500;
 378                  if(Tampe == 0)
 379                      Time_500mS_FLAG = 1;
 380                  Tampe = Timer1Count1 % 1000;
 381                  if(Tampe == 0)
 382                      Time_1S_FLAG = 1;
 383                  Tampe = Timer1Count1 % 10000;
 384                  if(Tampe == 0)
 385                  {
 386                      Time_10S_FLAG = 1;
 387                      Timer1Count1 = 0;
 388                      Timer1Count2 ++;
 389                      Tampe = Timer1Count2 % 6;
 390                      if(Tampe == 0)
 391                          Time_1Min_FLAG = 1;
 392                      Tampe = Timer1Count2 % 60;
 393                      if(Tampe == 0)
 394                      {
 395                          Time_1H_FLAG = 1;
 396                          Timer1Count2 = 0;
 397                      }
 398                  }
 399              }
 400          }
 401          */
 402          
 403          /***************************************************************************************
 404            * @ËµÃ÷   ÏµÍ³ÈÎÎñ´¦Àíº¯Êý
 405            * @²ÎÊý   ÎÞ
 406            * @·µ»ØÖµ ÎÞ
 407            * @×¢     ÎÞ
 408          ***************************************************************************************/
 409          
 410          /*
 411          void System_Task(void)
 412          {
 413              u8 temp;
 414              if(Time_10mS_FLAG)
 415              {
 416                  Time_10mS_FLAG = 0;
 417                  //User TASK
 418                  
 419                  
 420                  //User TASK
 421                  if(Time_100mS_FLAG)
 422                  {
 423                      Time_100mS_FLAG = 0;
 424                      //User TASK
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 8   

 425          
 426                  
 427                  
 428                      //User TASK
 429                  }
 430                  if(Time_200mS_FLAG)
 431                  {
 432                      Time_200mS_FLAG = 0;
 433                      //User TASK
 434          
 435                  
 436                  
 437                      //User TASK
 438                  }
 439                  if(Time_500mS_FLAG)
 440                  {
 441                      Time_500mS_FLAG = 0;
 442                      //User TASK
 443                      AN1_Data = Read_ADC(0x01);
 444                    
 445                      //User TASK
 446                  }
 447                   if(Time_1S_FLAG)
 448                  {
 449                      Time_1S_FLAG = 0;
 450                      //User TASK
 451          
 452                      temp = 0xFF & (AN1_Data >> 8);
 453                      SBUF = temp;
 454                      while(!(SCON & 0x02));
 455                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 456                      temp = 0xFF & AN1_Data;
 457                      SBUF = temp;
 458                      while(!(SCON & 0x02));
 459                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 460                      P0_0 =~ P0_0; 
 461                      //User TASK
 462                      
 463                  }
 464                  if(Time_10S_FLAG)
 465                  {
 466                      Time_10S_FLAG = 0;
 467                      //User TASK
 468                      
 469          
 470                      //User TASK
 471                  }
 472                  if(Time_1Min_FLAG)
 473                  {
 474                      Time_1Min_FLAG = 0;
 475                      //User TASK
 476                  
 477                  
 478                  
 479                      //User TASK
 480                  }
 481                  if(Time_1H_FLAG)
 482                  {
 483                      Time_1H_FLAG = 0;
 484                      //User TASK
 485                  
 486                  
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 9   

 487                  
 488                      //User TASK
 489                  }
 490              }
 491          }
 492          */
 493          
 494          void send_data(u8 d)
 495          {
 496   1          SBUF = d;
 497   1          while(!(SCON & 0x02));
 498   1          SCON &=~ 0x02;
 499   1      }
 500          
 501          uchar read_ad(uchar ch)
 502          {
 503   1        u8 i;
 504   1        uint  ad_sum;
 505   1        
 506   1      //  switch (ch)
 507   1      //  {
 508   1      //    case 3:
 509   1      //      ADC_P16_AN3;
 510   1      //      break;
 511   1      //    case 4:
 512   1      //      ADC_P15_AN4;
 513   1      //      break;
 514   1      //    case 5:
 515   1      //      ADC_P14_AN5;
 516   1      //      break;
 517   1      //  }
 518   1        
 519   1        
 520   1      //  if(ch==3)
 521   1      //  {
 522   1      //    ADC_P16_AN3;
 523   1      //  }
 524   1      //  else if(ch==4)
 525   1      //  {
 526   1      //    ADC_P15_AN4;
 527   1      //  }
 528   1        
 529   1        ADCC1 = ch;             //Ñ¡ÔñÍâ²¿Í¨µÀ
 530   1        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 531   1        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 532   1        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 533   1        
 534   1        //ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ 
 535   1        
 536   1      //  delay_ms(1);
 537   1      //  
 538   1      //  ADC_TG; 
 539   1        Delay_us(100);
 540   1        
 541   1        ad_sum=0;
 542   1        //ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 543   1        
 544   1        
 545   1        for(i=0;i<16;i++)
 546   1        {
 547   2      //    ADC_TG; 
 548   2      //    while(ADC_IF==0){};
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 10  

 549   2      //    //adc_data = ADC_DATA_RD();
 550   2      //      
 551   2      //    k=ADC_DH;
 552   2      //    k =k <<8;
 553   2      //    k+=ADC_DL;
 554   2      //      
 555   2      //    ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 556   2      //    ad_sum+=k;
 557   2            
 558   2      
 559   2          ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 560   2          while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 561   2          ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 562   2          ad_sum += ADCR;       //»ñÈ¡ADCµÄÖµ
 563   2          
 564   2          Delay_us(20);
 565   2        }
 566   1        
 567   1        //ADC_P14_AN5;
 568   1        ADCC1 =1;   //ÇÐ»»µ½an1
 569   1        i=ad_sum>>8;
 570   1        
 571   1        Delay_us(100);
 572   1        return(i);
 573   1        
 574   1      }
 575          
 576          void set_var(void)
 577          {
 578   1        
 579   1        Flash_ReadArr(0X2f00,10,guc_Read_a);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 580   1        
 581   1        TH=guc_Read_a[0];
 582   1        TH<<=8;
 583   1        TH+=guc_Read_a[1];
 584   1        TH*=1000;
 585   1        if(TH<TH_LOW||TH>TH_HIGH)TH=TH_DEF;
 586   1        
 587   1          
 588   1        LIGHT_TH=guc_Read_a[2];
 589   1      
 590   1        if(LIGHT_TH==0)LIGHT_TH=LIGHT_TH0;
 591   1        else 
 592   1          if(LIGHT_TH==0XFE)LIGHT_TH=255;
 593   1      
 594   1        DELAY_NUM=guc_Read_a[3];
 595   1        DELAY_NUM<<=8;
 596   1        DELAY_NUM+=guc_Read_a[4];
 597   1        if(DELAY_NUM==0||DELAY_NUM>MAX_DELAY)DELAY_NUM=5;
 598   1        
 599   1        //DELAY_NUM<<=2;
 600   1        lightvalue=guc_Read_a[5];
 601   1        //if(lightvalue>100)lightvalue=10;
 602   1        XRBoffbrightvalue = lightvalue;
 603   1        
 604   1        lowlightDELAY_NUM = guc_Read_a[6];
 605   1        if(lowlightDELAY_NUM==0||lowlightDELAY_NUM>255)lowlightDELAY_NUM=1;
 606   1        
 607   1        SWITCHfXBR = (guc_Read_a[7])&0x01;
 608   1      //  addr = guc_Read_a[7];
 609   1      //  
 610   1      //  devgroup = guc_Read_a[8];
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 11  

 611   1      
 612   1      //  addrend = guc_Read_a[9];
 613   1        
 614   1        Flash_ReadArr(0X2f80,1,guc_Read_a1);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 615   1        resetbtcnt = guc_Read_a1[0];
 616   1      }
 617          
 618          
 619          void XBRHandle(void)
 620          {
 621   1        //u8 i,j;
 622   1        u16 k;
 623   1      //    if(while_1flag==0)
 624   1      //    send_data(0x55);
 625   1          //while(1)
 626   1          if(while_1flag==0)
 627   1          {
 628   2            //send_data(0x66);
 629   2      //        ADC_TG; 
 630   2      //        while(ADC_IF==0){};
 631   2      //        //adc_data = ADC_DATA_RD();
 632   2      //          
 633   2      //        k = ADC_DH<<8;
 634   2      //        //adc_data =adc_data <<8;
 635   2      //        k+= ADC_DL;
 636   2      //          
 637   2      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 638   2      
 639   2            ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 640   2            while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 641   2            ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 642   2            k = ADCR;       //»ñÈ¡ADCµÄÖµ
 643   2            
 644   2            times++;
 645   2            
 646   2            SUM+=k;
 647   2      
 648   2            //¼ÆËãÐÅºÅÖµÓëÖ±Á÷µçÑ¹Æ«²îÖµ
 649   2            if(k>average){k-=average;}
 650   2            else {k=average-k;}
 651   2            SUM1+=k;
 652   2      
 653   2            if((times&0x1ff)==0)
 654   2            {
 655   3              if(LIGHT>0) //????
 656   3              {
 657   4                
 658   4                //LIGHT++;
 659   4                
 660   4                if(slowchcnt<100)
 661   4                {
 662   5                  slowchcnt = slowchcnt+2;//
 663   5                  if(slowchcnt>100)
 664   5                  {
 665   6                    slowchcnt = 100;
 666   6                  }
 667   5                }
 668   4                PWM3init(slowchcnt);
 669   4              }
 670   3              else if((SWITCHflag2==0)&&(LIGHT_off ==1))
 671   3              {
 672   4                if(slowchcnt>lightvalue)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 12  

 673   4                {
 674   5                  if(slowchcnt>=2)slowchcnt-=2;
 675   5                  if(slowchcnt<lightvalue)slowchcnt=lightvalue;
 676   5                }
 677   4                PWM3init(slowchcnt);
 678   4              }
 679   3            }
 680   2            
 681   2            if(times>=8192) //250ms   //12800)  //330ms
 682   2            {
 683   3      
 684   3              WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 685   3              
 686   3              times=0;
 687   3      
 688   3              calc_average_times++;
 689   3            
 690   3              SUM16+=SUM;
 691   3              
 692   3              if(calc_average_times>=8) //Ã¿2.5SÖØÐÂ¼ÆËãÒ»´ÎÖ±Á÷µçÑ¹Öµ
 693   3              {
 694   4                calc_average_times=0;
 695   4                
 696   4                SUM16>>=16;
 697   4                //SUM16/=96000;//102400;
 698   4                average+=SUM16;
 699   4                average/=2;
 700   4                SUM16=0;
 701   4              }
 702   3              
 703   3              if(check_light_times<8) //2s  ¶ÁÈ¡Ò»´Î¸Ð¹âADÖµ
 704   3              {
 705   4                check_light_times++;
 706   4              }
 707   3              else
 708   3              {
 709   4                if(LIGHT==0)  
 710   4                {
 711   5                  //light_ad=READ_LIGHT();
 712   5                  light_ad=read_ad(10);   //ÇÐ»»µ½an10
 713   5      
 714   5                  if((light_ad<=(light_ad0+2))&&(light_ad0<=(light_ad+2)))
 715   5                    light_ad=light_ad0;
 716   5      
 717   5                  light_ad0=light_ad;
 718   5      
 719   5                  check_light_times=0;
 720   5                }
 721   4              }
 722   3      
 723   3              if(SUM0==0)
 724   3              {
 725   4                SUM0=SUM1+5000; 
 726   4                if(start_times==0&&SUM0>1000000)SUM0=1000000;
 727   4              }
 728   3      
 729   3              if(SUM1_counter==0)
 730   3              {
 731   4                SUM10=SUM1;
 732   4                MAX_DELTA=1;//SUM10>>3;   
 733   4                //if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 734   4              }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 13  

 735   3              
 736   3                if((SUM10<(SUM1+MAX_DELTA))&&(SUM1<(SUM10+MAX_DELTA)))//???????????
 737   3                {
 738   4                  SUM1_counter++;
 739   4                  ALL_SUM1+=SUM1;
 740   4                  SUM10=ALL_SUM1/SUM1_counter;
 741   4                  MAX_DELTA=SUM10>>3;
 742   4                  if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 743   4                  if(MAX_DELTA>MAX_DELTA1)MAX_DELTA=MAX_DELTA1;
 744   4                  
 745   4                  if(SUM0>SUM10)
 746   4                  {
 747   5                    SUM=SUM0-SUM10;
 748   5                    if(SUM>80000)SUM0_num=6;
 749   5                    else if(SUM>40000)SUM0_num=9;
 750   5                    else SUM0_num=12;
 751   5                  }
 752   4                  else
 753   4                  {
 754   5                    SUM0_num=12;
 755   5                  }
 756   4                  
 757   4                  if((SUM1_counter>=SUM0_num)&&(SUM10<SUM0))
 758   4                  {
 759   5                    if(SUM1_num>16) //???????????????
 760   5                    {
 761   6                      if(SUM0_num<=9)SUM0=SUM10;
 762   6                      else if(SUM0>(SUM10+4000))
 763   6                      {
 764   7                        SUM0+=SUM10;
 765   7                        SUM0/=2;
 766   7                      }
 767   6                      SUM1_counter=0;
 768   6                      ALL_SUM1=0;
 769   6                    }
 770   5                  }
 771   4      
 772   4                  else if(SUM1_counter>=SUM1_num)
 773   4                  {
 774   5                    
 775   5      //              if(SUM0>SUM10)
 776   5      //              {
 777   5      //                if(SUM1_num>16)SUM0=SUM10;  //???????????????
 778   5      //              }
 779   5      //              else 
 780   5                      
 781   5                    if(SUM10>(SUM0+4000))
 782   5                    {
 783   6                      SUM=SUM10-SUM0;
 784   6      
 785   6                      if((SUM10<8000000)&&(SUM<400000))
 786   6          //????????????,???????????????100000?,???????
 787   6                      {
 788   7                        if(SUM1_num>16) //????????????
 789   7                        {
 790   8                          SUM0+=SUM10;
 791   8                          SUM0/=2;
 792   8                        }
 793   7                        else
 794   7                        {
 795   8                          if(SUM>300000)SUM1_num=16;
 796   8                          else if(SUM>150000)SUM1_num=12;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 14  

 797   8                          else SUM1_num=8;
 798   8                          if(SUM1_counter>=SUM1_num)
 799   8                          {
 800   9                            SUM0+=SUM10;
 801   9                            SUM0/=2;
 802   9                          }
 803   8                        }
 804   7                      }
 805   6                    }
 806   5      //              else if((LIGHT>0)&&(TH==TH_LOW))
 807   5      //              {
 808   5      //                SUM=SUM10-SUM0; 
 809   5      //                TH+=SUM;    //?????????????
 810   5      //              }
 811   5      
 812   5                    if(SUM1_counter>=SUM1_num)
 813   5                    {
 814   6                      SUM1_counter=0;
 815   6                      ALL_SUM1=0;
 816   6                    }
 817   5                  }
 818   4                }
 819   3                else
 820   3                {
 821   4                  SUM1_counter=0;
 822   4                  ALL_SUM1=0;
 823   4                }
 824   3      
 825   3      
 826   3      //        //send_byte=0x35;
 827   3      //        check_sum=0xFa;
 828   3              //send_data(0xFa);
 829   3      
 830   3      //        send_byte=TH>>15;
 831   3      //        check_sum+=send_byte;
 832   3      //        send_data(send_byte);
 833   3      
 834   3      //        //k=TH;
 835   3      //        send_byte=TH>>10;
 836   3      //        check_sum+=send_byte;
 837   3      //        send_data(send_byte);
 838   3      //          
 839   3      //        send_byte=LIGHT_TH;
 840   3      //        check_sum+=send_byte;
 841   3      //        send_data(send_byte);         
 842   3      
 843   3      //        //send_byte=light_ad;
 844   3      //        check_sum+=light_ad;
 845   3      //        send_data(light_ad);
 846   3      
 847   3      //        send_byte=average>>4;
 848   3      //        check_sum+=send_byte;
 849   3      //        send_data(send_byte);
 850   3      
 851   3      //        send_byte=SUM0>>16;
 852   3      //        check_sum+=send_byte;
 853   3      //        send_data(send_byte);
 854   3      
 855   3      //        send_byte=SUM0>>8;
 856   3      //        check_sum+=send_byte;
 857   3      //        send_data(send_byte);
 858   3      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 15  

 859   3      //        send_byte=SUM1>>16;
 860   3      //        check_sum+=send_byte;
 861   3      //        send_data(send_byte);
 862   3      
 863   3      //        send_byte=SUM1>>8;
 864   3      //        check_sum+=send_byte;
 865   3      //        send_data(send_byte);
 866   3      
 867   3      //        check_sum+=1;
 868   3      //        send_data(check_sum);
 869   3      
 870   3              if(stop_times>0)  //
 871   3              {
 872   4                stop_times--; 
 873   4                if((SUM0>(SUM01+6000))&&(SUM1<(SUM01+15000)))SUM0=SUM01+6000;
 874   4              }
 875   3              else
 876   3              {
 877   4              
 878   4                if(start_times>0)
 879   4                {
 880   5                  start_times--;
 881   5                  
 882   5                  if(start_times>0) //???????????,???????250*88ms=22S?????????          
 883   5                  {
 884   6                    //start_times++;
 885   6      /*
 886   6                    if(SUM0>600000)
 887   6                    {
 888   6                      TH=10000;
 889   6                    }
 890   6                    else */
 891   6                    if(SUM0>8000000)
 892   6                    {
 893   7                      TH=800000;
 894   7                    }
 895   6                    else
 896   6                    {
 897   7                      SUM=SUM0+TH;
 898   7                      if(SUM>9000000)
 899   7                      {
 900   8                        TH=9000000-SUM0;
 901   8                      }
 902   7                      //if(TH<30000)TH=30000;
 903   7                    }
 904   6      
 905   6                  }
 906   5                  else
 907   5                  {
 908   6                    //TH=TH_LOW;
 909   6                    //start_times=0;
 910   6      //              EA=0;
 911   6      //              set_var();
 912   6      //              EA=1;
 913   6                  }
 914   5      
 915   5                }
 916   4      
 917   4                if(SUM1>(SUM0+TH))
 918   4                {
 919   5                  //SUM=SUM1-SUM0;
 920   5      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 16  

 921   5                //  if(SUM>TH)
 922   5                //  {
 923   5                    if((light_ad<=LIGHT_TH)||(start_times>0))
 924   5                    {
 925   6      //                send_data(0xaa);
 926   6      
 927   6                      
 928   6                      //if(alarm_times<2)
 929   6                      //{
 930   6                      //  alarm_times++;
 931   6                    //    }
 932   6                      //if(alarm_times>=2)  //??????????????
 933   6                      {
 934   7                        if(LIGHT==0)SUM01=SUM0;
 935   7                        LIGHT=1;
 936   7                    
 937   7                        //PC3=0;
 938   7                        //LIGHT_ON;
 939   7                        //slowchcnt = slowchcnt+20;//
 940   7                        //if(slowchcnt>100)
 941   7                        //{
 942   7                        //  slowchcnt = 100;
 943   7                        //}
 944   7                        //PWM3init(slowchcnt);
 945   7                        //P0_6=0;
 946   7      //                  send_data(0xaa);
 947   7      //                  send_data((TH/1000)>>8);
 948   7      //                  send_data((TH/1000)&0xff);
 949   7      //                  send_data(LIGHT_TH);
 950   7      //                  send_data(DELAY_NUM>>10);
 951   7      //                  send_data(DELAY_NUM>>2);    //²âÊÔÓÃ
 952   7      //                  send_data(slowchcnt);
 953   7      //                  send_data(0xaa);  
 954   7                        send_data(0xdd);
 955   7      
 956   7                        SUM1_num=8;
 957   7                        LIGHT_off=0;
 958   7                        light1scount=0;
 959   7                        light1sflag=0;
 960   7        //                send_data(0xaa);
 961   7      
 962   7                      }
 963   6                    }
 964   5                
 965   5                  }
 966   4      
 967   4              }
 968   3      
 969   3              SUM2=SUM1;
 970   3              send_data(average>>4);
 971   3              send_data(light_ad);
 972   3              send_data(SUM0>>16);
 973   3              send_data(SUM0>>8);
 974   3              send_data(SUM2>>16);
 975   3              send_data(SUM2>>8);     //20200927  ²âÊÔÓÃ        
 976   3              
 977   3              SUM=0;
 978   3              SUM1=0;
 979   3              
 980   3              if(LIGHT>0) //????
 981   3              {
 982   4                
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 17  

 983   4                //LIGHT++;
 984   4                
 985   4      //          slowchcnt = slowchcnt+5;//
 986   4      //          if(slowchcnt>=100)
 987   4      //          {
 988   4      //            slowchcnt = 100;
 989   4      //          }
 990   4      //          PWM3init(slowchcnt);
 991   4                
 992   4                if(LIGHT>DELAY_NUM)
 993   4                {
 994   5                  LIGHT=0;
 995   5                  while_1flag=1;
 996   5                  //while_2flag = 0;
 997   5                  //break;
 998   5                }
 999   4              }
1000   3              
1001   3              
1002   3            }
1003   2      
1004   2      
1005   2          }
1006   1          else
1007   1          {
1008   2              LIGHT_off = 1;
1009   2              while_1flag=0;
1010   2              //if(while_2flag==0)
1011   2              //{
1012   2              //  while_2flag = 1;
1013   2      //          send_data(0x55);
1014   2              //}
1015   2              //PC3=1;
1016   2              //LIGHT_OFF;
1017   2              //slowchcnt = lightvalue;
1018   2              //PWM3init(lightvalue);
1019   2              lowlight1mincount = 0;
1020   2              lowlight1minflag = 0;
1021   2              
1022   2            
1023   2              //P0_6=1;
1024   2              //send_data(0x55);
1025   2              Delay_ms(250);
1026   2      
1027   2      
1028   2              
1029   2          //    SUM=0;
1030   2          //    SUM1=0;
1031   2          //    times=0;
1032   2              
1033   2              SUM16=0;
1034   2              calc_average_times=0;
1035   2              SUM1_num=64;
1036   2              
1037   2              stop_times=2;
1038   2              //if(start_times==0)TH=TH_LOW;
1039   2              check_light_times=6;
1040   2              
1041   2              SUM1_counter=0;
1042   2              ALL_SUM1=0;
1043   2      
1044   2          //    send_data(0xdd);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 18  

1045   2          //    send_data(0xdd);
1046   2          }
1047   1      
1048   1      }
1049          
1050          
1051          void wait1(void)
1052          {
1053   1        u8 i,j;
1054   1      
1055   1        //µÈ´ýÖ±Á÷µçÑ¹ÎÈ¶¨
1056   1        j=0;
1057   1        while(1)
1058   1        {
1059   2          SUM=0;
1060   2          
1061   2          
1062   2      //    for(i=0;i<4;i++)  //0.52s
1063   2      //    {
1064   2      //      for(t=0;t<8192;t++) //0.13s
1065   2      //      {
1066   2      
1067   2      //        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1068   2      //        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1069   2      //        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1070   2      //        k = ADCR;       //»ñÈ¡ADCµÄÖµ
1071   2      //        
1072   2      //        SUM+=k;
1073   2      //  
1074   2      //      }
1075   2      //      
1076   2      //      WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1077   2            
1078   2      
1079   2            for(i=0;i<128;i++)  //
1080   2            {
1081   3      
1082   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1083   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1084   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1085   3              //k = ADCR;       //»ñÈ¡ADCµÄÖµ
1086   3              
1087   3              SUM+=ADCR;
1088   3              
1089   3            }
1090   2      
1091   2      //·¢ËÍ¸Ð¹âADÖµ
1092   2      //        send_byte=0xFA;
1093   2      //        check_sum=send_byte;
1094   2      //        send_data(send_byte);
1095   2      
1096   2      //        //send_byte=light_ad;
1097   2      //        check_sum+=light_ad;
1098   2      //        send_data(light_ad);
1099   2      
1100   2      //        check_sum+=light_ad;
1101   2      //        send_data(light_ad);
1102   2      //        
1103   2      //        check_sum+=1;
1104   2      //        send_data(check_sum);
1105   2      
1106   2      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 19  

1107   2      
1108   2        //}
1109   2          
1110   2          Delay_ms(400);
1111   2            
1112   2      
1113   2          
1114   2          //WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1115   2      
1116   2          i=SUM>>11;
1117   2          if((i>12)&&(i<141)&&(j>20))break;
1118   2      
1119   2          j++;
1120   2      
1121   2          if(j>80)break;  //??35????????????1.1V???????
1122   2      
1123   2        }
1124   1      }
1125          void wait2(void)
1126          {
1127   1        u8 i;
1128   1        //u8 j;
1129   1        u16 k,t;
1130   1      
1131   1        SUM=0;
1132   1      
1133   1      
1134   1          for(i=0;i<8;i++)
1135   1          {
1136   2            for(t=0;t<8192;t++) 
1137   2            {
1138   3      //        ADC_TG; 
1139   3      //        while(ADC_IF==0){};
1140   3      //        //adc_data = ADC_DATA_RD();
1141   3      //          
1142   3      //        k = ADC_DH<<8;
1143   3      //        //adc_data =adc_data <<8;
1144   3      //        k+= ADC_DL;
1145   3      //          
1146   3      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
1147   3          
1148   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1149   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1150   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1151   3              k = ADCR;       //»ñÈ¡ADCµÄÖµ
1152   3              
1153   3              SUM+=k;
1154   3        
1155   3            }
1156   2            WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1157   2      
1158   2          }
1159   1      
1160   1          average=SUM>>16;
1161   1      
1162   1      
1163   1      //  light_ad=read_ad(10);
1164   1      //  light_ad0=light_ad;
1165   1      
1166   1      //  Delay_ms(4);  //4ms
1167   1      }
1168          
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 20  

1169          unsigned char PWM3init(unsigned char ab)
1170          {
1171   1         float i11;
1172   1        unsigned char j11;
1173   1        i11=ab*255/100;
1174   1        j11=i11;
1175   1        #ifdef V11
              /************************************PWM3³õÊ¼»¯****************************************/
                //P0M3 = P0M3&0xF0|0x08;    //P06ÉèÖÃÎªÍÆÍìÊä³ö
                PWM3_MAP = 0x05;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1181   1        
1182   1        #ifdef V10
                PWM3_MAP = 0x06;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1186   1      
1187   1        #ifdef V12
1188   1        PWM3_MAP = 0x10;          //PWM3Ó³ÉäP10¿Ú
1189   1        
1190   1        #endif  
1191   1        
1192   1          //ÖÜÆÚ¼ÆËã  = 0xFF / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1193   1        //      = 0xFF /(16000000 / 4)      
1194   1        //      = 255 /4000000
1195   1        //      = 63.75us   ¼´15.69KHZ    
1196   1      
1197   1        PWM3P = 0xFF;             //PWMÖÜÆÚÎª0xFF
1198   1        //ÓÐÐ§µçÆ½Ê±¼ä¼ÆËã£¨¼´Õ¼¿Õ±È£©  
1199   1        //      = 0x55 / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1200   1        //      = 0x55 /(16000000 / 4)      
1201   1        //      = 85 /4000000
1202   1        //      = 21.25us   Õ¼¿Õ±ÈÎª 21.25 / 63.75 = 34%
1203   1      
1204   1        PWM3D = j11;              //PWMÕ¼¿Õ±ÈÉèÖÃ
1205   1        PWM3C = 0x94;             //Ê¹ÄÜPWM3£¬¹Ø±ÕÖÐ¶Ï£¬ÔÊÐíÊä³ö£¬Ê±ÖÓ16·ÖÆµ
1206   1        
1207   1        return 0;
1208   1      }
1209          
1210          /***************************************************************************************
1211            * @ËµÃ÷   Ö÷º¯Êý
1212            * @²ÎÊý   ÎÞ
1213            * @·µ»ØÖµ ÎÞ
1214            * @×¢     ÎÞ
1215          ***************************************************************************************/
1216          void main()
1217          {
1218   1        //u8 i,j;
1219   1        bt_protocol_init();   //mcu_sdk
1220   1        InitSYS();
1221   1        GPIO_Init();
1222   1        //LIGHT_ON;
1223   1        //P0_6=0;
1224   1        PWM3init(100);
1225   1        Timer_Init();
1226   1        UART1_Init();
1227   1        ADC_Init();
1228   1      
1229   1        LVDC = 0xAA;              //LVDÉèÖÃ2.4V,½ûÖ¹ÖÐ¶Ï
1230   1        //  Ïû¶¶Ê±¼ä =  (0xFF + 2) * 1/Fcpu
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 21  

1231   1        //       =  (0xFF + 2) / 16000000 £¨µ±Ç°µÄCPUÊ±ÖÓ£©
1232   1        //       =  16.0625us
1233   1        LVDDBC = 0xFF;            //ÉèÖÃÏû¶¶Ê±¼ä
1234   1        LVDC &=~ 0x08;            //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»   
1235   1      //  
1236   1        EA=1;
1237   1        
1238   1        Delay_ms(200);
1239   1        
1240   1        //LIGHT_ON;
1241   1        PWM3init(100);
1242   1        SWITCHflag = 1;
1243   1        light_ad=read_ad(10);
1244   1        light_ad0=light_ad;
1245   1        
1246   1        EA=0;
1247   1        set_var();  //´Óflash¶ÁÈ¡³ö±äÁ¿
1248   1        
1249   1        //for(i=0;i<5;i++)send_data(guc_Read_a[i]);
1250   1        
1251   1      //  TXdata[0]=VERSION;
1252   1      //  t=TH/1000;
1253   1      //  TXdata[1]=t>>8;
1254   1      //  TXdata[2]=t;
1255   1      //  TXdata[3]=LIGHT_TH;
1256   1      //  t=DELAY_NUM/4;
1257   1      //  TXdata[4]=t>>8;
1258   1      //  TXdata[5]=t;
1259   1      
1260   1      //  TXdata[6]=light_ad;
1261   1      
1262   1      //  for(i=0;i<7;i++)send_data(TXdata[i]); 
1263   1        resetbtcnt++;
1264   1        
1265   1        Flash_EraseBlock(0x2F80);
1266   1        Delay_us_1(10000);
1267   1        FLASH_WriteData(resetbtcnt, 0x2F80);
1268   1        Delay_us_1(100);
1269   1        
1270   1        EA=1;
1271   1        
1272   1        wait1();
1273   1      
1274   1        slowchcnt = lightvalue;
1275   1        //Delay_ms(200);
1276   1        PWM3init(lightvalue);
1277   1        //LIGHT_OFF;
1278   1        //P0_6=1;
1279   1        Delay_ms(300);
1280   1        
1281   1        wait2();
1282   1      
1283   1        SUM=0;
1284   1        while(1)
1285   1        {
1286   2          if(resetbtcnt>=3)
1287   2          {
1288   3            resetbtcnt = 0;
1289   3            send_data(0x55);//p15£¬ÖØÖÃÄ£¿é
1290   3            send_data(0xAA);
1291   3            send_data(0X00);
1292   3            send_data(0X04);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 22  

1293   3            send_data(0X00);
1294   3            send_data(0X00);
1295   3            send_data(0X03);
1296   3            
1297   3          }
1298   2          if(check_group_count <=2)//Ò»ÉÏµç¼ä¸ôÒ»Ãë»ñÈ¡3´ÎÈº×éµØÖ·
1299   2          {
1300   3            if(check_group_flag == 1)
1301   3            {
1302   4                check_group_flag = 0;
1303   4                check_group_count ++;
1304   4              
1305   4                send_data(0x55);
1306   4                send_data(0xAA);
1307   4                send_data(0X00);
1308   4                send_data(0XB4);
1309   4                send_data(0X00);
1310   4                send_data(0X00);
1311   4                send_data(0Xb3);
1312   4              
1313   4            
1314   4            }
1315   3            
1316   3          
1317   3          }
1318   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1319   2          
1320   2          
1321   2          if(while_1flag==0)
1322   2          {
1323   3            if((times&0x1f)==0)
1324   3              bt_uart_service();
1325   3          }
1326   2          
1327   2          if(SWITCHfXBR==1)//À×´ï¿ª, app¿ØÖÆ
1328   2          {
1329   3            if(while_2flag==0)
1330   3            {
1331   4              while_1flag=0;
1332   4      
1333   4              while_2flag = 1;
1334   4              slowchcnt = lightvalue;
1335   4      
1336   4              
1337   4              SUM16=0;
1338   4              calc_average_times=0;
1339   4              SUM1_num=64;
1340   4              
1341   4              stop_times=2;
1342   4              //if(start_times==0)TH=TH_LOW;
1343   4              check_light_times=6;
1344   4              
1345   4              SUM1_counter=0;
1346   4              ALL_SUM1=0;
1347   4            }
1348   3            
1349   3            XBRHandle();
1350   3            
1351   3            if(LIGHT_off>0)//¹ØµÆÑÓÊ±
1352   3            {
1353   4              if(lowlight1minflag==1)
1354   4              {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 23  

1355   5                lowlight1minflag = 0;
1356   5                LIGHT_off++;
1357   5                if(LIGHT_off>=lowlightDELAY_NUM)
1358   5                {
1359   6                  LIGHT_off=0;
1360   6                  PWM3init(0);
1361   6      
1362   6                }
1363   5              }
1364   4            }
1365   3            if(LIGHT>0)//ÁÁµÆÑÓÊ±
1366   3            {
1367   4              if(light1sflag==1)
1368   4              {
1369   5                light1sflag = 0;
1370   5                LIGHT++;
1371   5                //slowchcnt = slowchcnt+20;//
1372   5      //          if(slowchcnt>100)
1373   5      //          {
1374   5      //            slowchcnt = 100;
1375   5      //          }
1376   5      //          PWM3init(slowchcnt);
1377   5              }
1378   4            }
1379   3            
1380   3          }
1381   2          else
1382   2          {//À×´ï¹Ø
1383   3            while_2flag = 0;
1384   3            if(SWITCHflag2==0)//¹ØµÆ
1385   3            {
1386   4              PWM3init(0);
1387   4            }
1388   3            else
1389   3            {//¹ØµÆ
1390   4              PWM3init(XRBoffbrightvalue);
1391   4              
1392   4              while_1flag=0;
1393   4      
1394   4              slowchcnt = lightvalue;
1395   4              //PWM3init(lightvalue);
1396   4      
1397   4              
1398   4              SUM16=0;
1399   4              calc_average_times=0;
1400   4              SUM1_num=64;
1401   4              
1402   4              stop_times=2;
1403   4              //if(start_times==0)TH=TH_LOW;
1404   4              check_light_times=6;
1405   4              
1406   4              SUM1_counter=0;
1407   4              ALL_SUM1=0;
1408   4              
1409   4            }
1410   3            
1411   3          
1412   3          }
1413   2      
1414   2        } 
1415   1        
1416   1      //  while(1)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 24  

1417   1      //  {
1418   1      //    System_Time_Cnt();
1419   1      //    System_Task();
1420   1      //    WDTC |= 0x10;              //Çå¹·
1421   1      //  }
1422   1      
1423   1        
1424   1        
1425   1      }
1426          
1427          /***************************************************************************************
1428            * @ËµÃ÷   T1ÖÐ¶Ï·þÎñº¯Êý
1429            * @²ÎÊý   ÎÞ
1430            * @·µ»ØÖµ ÎÞ
1431            * @×¢     ÎÞ
1432          ***************************************************************************************/
1433          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR
1434          {
1435   1        //Timer1_FLAG = 1;    //1mS
1436   1        Timer_Counter++;
1437   1      
1438   1        lowlight1mincount++;
1439   1        if(lowlight1mincount>=60000)
1440   1        {
1441   2          lowlight1mincount = 0;
1442   2          lowlight1minflag = 1;
1443   2        }
1444   1        light1scount++;
1445   1        if(light1scount>=1000)
1446   1        {
1447   2          check_group_flag = 1;
1448   2          light1scount=0;
1449   2          light1sflag=1;
1450   2        }
1451   1      
1452   1        
1453   1      }
1454          
1455          /***************************************************************************************
1456            * @ËµÃ÷   UART1ÖÐ¶Ï·þÎñº¯Êý
1457            * @²ÎÊý   ÎÞ
1458            * @·µ»ØÖµ ÎÞ
1459            * @×¢     ÎÞ
1460          ***************************************************************************************/
1461          
1462          void UART1_Rpt(void) interrupt UART1_VECTOR
1463          {
1464   1        u8 i;
1465   1        //u16 t;
1466   1        
1467   1        if(SCON & 0x01)                       //ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1468   1        {
1469   2            i=SBUF;
1470   2            uart_receive_input(i);
1471   2            SCON &=~ 0x01;                    //Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1472   2            EA=1;
1473   2        }
1474   1      }
1475          
1476          void UART2_Rpt(void) interrupt UART2_VECTOR
1477          {
1478   1      }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 25  

1479          
1480          // void Delay_2us(u16 Cnt)
1481          // {
1482          //  while(Cnt--); 
1483          // }
1484          
1485          void Flash_EraseBlock(unsigned int fui_Address)
1486          {
1487   1        while(1)
1488   1        {
1489   2          LVDC &=~ 0x08;        //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1490   2          P0_0=0;   
1491   2          if((LVDC&0x08)==0)    break;
1492   2        }
1493   1        P0_0=1;   
1494   1        EA=0;
1495   1        IAP_CMD = 0xF00F;       //Flash½âËø
1496   1        IAP_ADDR = fui_Address; //Ð´Èë²Á³ýµØÖ·
1497   1        IAP_CMD = 0xD22D;       //Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ý
1498   1        IAP_CMD = 0xE11E;       //´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
1499   1        //EA=1;
1500   1      }
1501          
1502          /**
1503            * @ËµÃ÷   Ð´ÈëÒ»¸ö×Ö½ÚÊý¾Ýµ½FlashÀïÃæ
1504            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1505            * @²ÎÊý   fui_Address £ºFLASHµØÖ·
1506            * @²ÎÊý   fucp_SaveData£ºÐ´ÈëµÄÊý¾Ý
1507            * @·µ»ØÖµ ÎÞ
1508            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1509            */
1510          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
1511          {
1512   1        while(1)
1513   1        {
1514   2          LVDC &=~ 0x08;         //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1515   2          P0_0=0;   
1516   2          if((LVDC&0x08)==0)    break;
1517   2        }
1518   1        P0_0=1; 
1519   1        EA=0;
1520   1        IAP_DATA = fuc_SaveData;
1521   1        IAP_CMD=0xF00F;          //Flash½âËø
1522   1        IAP_ADDR = fui_Address;
1523   1        IAP_CMD=0xB44B;          //×Ö½Ú±à³Ì
1524   1        IAP_CMD=0xE11E;          //´¥·¢Ò»´Î²Ù×÷
1525   1        //EA=1;
1526   1      }
1527          
1528          /**
1529            * @ËµÃ÷   Ð´ÈëÈÎÒâ³¤¶ÈµÄÊý¾Ýµ½FLASHÀïÃæ
1530            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1531            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1532            * @²ÎÊý   fuc_Length £º Ð´ÈëÊý¾Ý³¤¶È
1533            *         È¡Öµ·¶Î§£º0x00-0xFF
1534            * @²ÎÊý  *fucp_SaveArr£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
1535            * @·µ»ØÖµ ÎÞ
1536            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1537            */
1538          
1539          // void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
1540          // {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 10:11:56 PAGE 26  

1541          //  unsigned char fui_i = 0;
1542          //  EA=0;
1543          //  for(fui_i=0;fui_i<fuc_Length;fui_i++)
1544          //  {
1545          //    FLASH_WriteData(*(fucp_SaveArr++), fui_Address++); 
1546          //  }
1547          //  EA=1;
1548          // }
1549          
1550          /**
1551            * @ËµÃ÷   ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊý¾Ý
1552            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1553            * @²ÎÊý   fuc_Length £º¶ÁÈ¡Êý¾Ý³¤¶È
1554            *         È¡Öµ·¶Î§£º0x00-0xFF
1555            * @²ÎÊý  *fucp_SaveArr£º¶ÁÈ¡Êý¾Ý´æ·ÅµÄÇøÓòÊ×µØÖ·
1556            * @·µ»ØÖµ ÎÞ
1557            * @×¢     ÎÞ
1558            */
1559          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4302    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     91    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      14
   IDATA SIZE       =     22    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

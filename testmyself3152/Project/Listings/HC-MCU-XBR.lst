C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HC_MCU_XBR
OBJECT MODULE PLACED IN .\Objects\HC-MCU-XBR.obj
COMPILER INVOKED BY: C:\Keil4\C51\BIN\C51.EXE ..\User\HC-MCU-XBR.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\HC-MCU-XBR
                    -.lst) TABS(2) OBJECT(.\Objects\HC-MCU-XBR.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89S003F4.h"
   3          //#include "Mcu_api.h"
   4          #include "bluetooth.h"
   5          
   6          #define V12
   7          
   8          
   9          
  10          #define  VERSION  0X21
*** WARNING C317 IN LINE 10 OF ..\User\HC-MCU-XBR.c: attempt to redefine macro 'VERSION'
  11          
  12          #define  TH_LOW   30000
  13          #define  TH_HIGH  4000000
  14          
  15          #define  TH_DEF   40000
  16            
  17          //ÔÊÐíÔëÉùÖµÆ«²î·¶Î§
  18          #define  MAX_DELTA0  20000
  19          #define  MAX_DELTA1  60000
  20          
  21          #define  MAX_DELAY  1800
  22          //×î´óÑÓÊ±ÃëÊý
  23          
  24          //¸Ð¹âÃÅÏÞ-30¶ÔÓ¦8LUX×óÓÒµÄADÖµ,ÉèÖÃÎª255±íÊ¾²»¼ì²â¸Ð¹â
  25          #define  LIGHT_TH0 255
  26          //30
  27          
  28          //Ò»¸ö¼ì²âÖÜÆÚÎª0.25Ãë
  29          //#define DELAY_NUM 20
  30          
  31          
  32          //#define LIGHT_ON P0_6=0
  33          //#define LIGHT_OFF P0_6=1
  34          
  35          //void Delay_2us(u16 Cnt);    //ÑÓÊ±º¯Êý
  36          
  37          // bit Timer1_FLAG;
  38          // bit Time_10mS_FLAG;
  39          // bit Time_100mS_FLAG;
  40          // bit Time_200mS_FLAG;
  41          // bit Time_500mS_FLAG;
  42          // bit Time_1S_FLAG;
  43          // bit Time_10S_FLAG;
  44          // bit Time_1Min_FLAG;
  45          // bit Time_1H_FLAG;
  46          
  47          volatile ulong Timer_Counter=0;
  48          
  49           //u8 Uart1_RX_Buff[10] = {0};           //ÓÃÓÚ´æ·ÅUART1½ÓÊÕÊý¾Ý
  50           //u8 Uart1_RX_Cnt = 0;                //UART1½ÓÊÕ¼ÆÊý
  51           //u8 Uart1_TX_Buff[20] = {0};           //ÓÃÓÚ´æ·ÅUART1·¢ËÍÊý¾Ý
  52           //u8 Uart1_TX_Cnt = 0;                //UART1·¢ËÍ¼ÆÊý
  53           
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 2   

  54          // u16 AN1_Data = 0;
  55          // u16 AN7_Data = 0;
  56          // u8 Uart_Cnt = 0;
  57          
  58          
  59            u8 xdata SUM1_counter=0,SUM1_num=64,SUM0_num=12;
  60            ulong xdata SUM1=0,SUM0=0,SUM=0,ALL_SUM1=0,SUM10=0,SUM16=0,SUM01,SUM2;
  61            u16   xdata times=0,start_times=1;
  62            ulong  xdata TH,MAX_DELTA;
  63            u8  xdata alarm_times=0,stop_times=0;
  64          
  65            uint  xdata average,LIGHT=0,LIGHT_off=0;
  66            u8  xdata light_ad,light_ad0,check_light_times=8,calc_average_times=0,check_sum,send_byte;
  67            u8  xdata LIGHT_TH;
  68            u16  xdata DELAY_NUM;
  69            u8 xdata lowlightDELAY_NUM;
  70            u8  xdata RXnum=0;
  71            u8 while_1flag = 0;
  72            u8 while_2flag = 0;
  73            u8 xdata  SWITCHflag = 0;
  74            u8 xdata  SWITCHflag2 = 0;
  75            u8 xdata  SWITCHfXBR = 1;
  76            u8      xdata lightvalue = 10;
  77            u8 xdata switchcnt = 0;
  78            u8 xdata slowchcnt = 10;
  79             u8 xdata resetbtcnt = 0;
  80             u8 xdata XRBoffbrightvalue = 0;
  81             volatile u16 xdata lowlight1mincount = 0;
  82             volatile u8 xdata  lowlight1minflag =0;
  83            volatile u16 idata light1scount  = 0;
  84            volatile u16 idata light1sflag = 0;
  85             u8 xdata addr = 0;
  86             u8 xdata devgroup = 0;
  87             u8 xdata addrend=0;
  88           unsigned char PWM3init(unsigned char ab);
  89          void Flash_EraseBlock(unsigned int fui_Address);//ÉÈÇø²Á³ý
  90          //void FLASH_WriteData(unsigned char fui_Address, unsigned int fuc_SaveData);//Ð´ÈëÒ»¸öÊý¾Ý
  91          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);
  92          //void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//Ð´È
             -ëÈÎÒâ³¤¶ÈÊý¾Ý
  93          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//¶ÁÈ¡ÈÎ
             -Òâ³¤¶ÈÊý¾Ý
  94          
  95          //unsigned char guc_Write_a[5] = {0}; //Ð´ÈëÊý¾Ý
  96          unsigned char xdata guc_Read_a[10] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
  97          unsigned char xdata guc_Read_a1[1] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
  98          // unsigned char guc_Uartflag = 0;            //·¢ËÍ±êÖ¾Î»
  99          // unsigned char guc_Uartcnt = 0;           //·¢ËÍ¼ÆÊý
 100          // unsigned char guc_Uartbuf_a[2] = {0x00}; //»º´æÊý×é
 101          
 102          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
 103          {
 104   1        while(fuc_Length--)
 105   1        *(fucp_SaveArr++)=*((unsigned char code *)(fui_Address++));//¶ÁÈ¡Êý¾Ý
 106   1      }
 107          
 108          void Delay_us(uint q)
 109          {
 110   1        uint j;
 111   1        for(j=0;j<q;j++)
 112   1        {
 113   2            ;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 3   

 114   2        }
 115   1      }
 116          
 117          void Delay_ms(uint t)
 118          {
 119   1        Timer_Counter=0;
 120   1        while(Timer_Counter<t)
 121   1        {
 122   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 123   2        }
 124   1        
 125   1      }
 126          
 127          void Delay_us_1(uint q1)
 128          {
 129   1        uint j;
 130   1        for(j=0;j<q1;j++)
 131   1        {
 132   2            ;
 133   2        }
 134   1      }
 135          
 136          
 137          
 138          // void Delay_ms(uint t)
 139          // {
 140          //  for(;t>0;t--)
 141          //  {
 142          //    Delay_us_1(1000);
 143          //    WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 144          //  }
 145          // }
 146          
 147          /***************************************************************************************
 148            * @ËµÃ÷   ÏµÍ³³õÊ¼»¯º¯Êý
 149            * @²ÎÊý   ÎÞ
 150            * @·µ»ØÖµ ÎÞ
 151            * @×¢     ÎÞ
 152          ***************************************************************************************/
 153          void InitSYS()
 154          {
 155   1        /********************************ÏµÍ³ÆµÂÊ³õÊ¼»¯***************************************/
 156   1        
 157   1        CLKSWR = 0x51;                     //Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
 158   1        CLKDIV = 0x01;                     //Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz 
 159   1        FREQ_CLK = 0x10;                   //IAPÆµÂÊ
 160   1        
 161   1        /**********************************µÍÑ¹¸´Î»³õÊ¼»¯**************************************/
 162   1        
 163   1      //  BORC = 0xC0;                       //Ê¹ÄÜµÍÑ¹¸´Î»1.8V£¬´øÏû¶¶Ê¹ÄÜ
 164   1      //  BORDBC = 0x01;                     //Ïû¶¶Ê±¼äBORDBC*8TCPU+2TCPU
 165   1        
 166   1        /***********************************¿´ÃÅ¿Ú³õÊ¼»¯***************************************/
 167   1        WDTC = 0x5F;                       //ÔÊÐíWDT¸´Î»£¬¿ÕÏÐÄ£Ê½ÏÂ½ûÖ¹WDT£¬Ñ¡Ôñ1024·ÖÆµ£¨ÄÚ²¿µÍÆµÊ±ÖÓ44K£©
 168   1        WDTCCR = 0X20;  //0X20/44 =0.73Ãë           //0xFF;  //Òç³öÊ±¼äÔ¼6Ãë
 169   1        //Òç³ö¼ÆËãÊ±¼ä=£¨WDT·ÖÆµÏµÊý*£¨WDTCCR+1£©£©/ÄÚ²¿µÍÆµRCÆµÂÊ
 170   1      }
 171          
 172          /***************************************************************************************
 173            * @ËµÃ÷   ¶¨Ê±Æ÷³õÊ¼»¯º¯Êý
 174            * @²ÎÊý   ÎÞ
 175            * @·µ»ØÖµ ÎÞ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 4   

 176            * @×¢     ÎÞ
 177          ***************************************************************************************/
 178          void Timer_Init()
 179          {
 180   1        /**********************************TIM1ÅäÖÃ³õÊ¼»¯**************************************/
 181   1        TCON1 = 0x00;             //T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 182   1        TMOD = 0x01;              //T1-16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷,T0-16Î»¶¨Ê±Æ÷
 183   1      
 184   1        //Tim1¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊý))
 185   1        //        = 1333 / (16000000 / 12)
 186   1        //        = 1 ms
 187   1      
 188   1        //¶¨Ê±1ms
 189   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊý)))
 190   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 191   1        //      = 65536 - 1333
 192   1        //      = 0xFACB
 193   1        
 194   1        TH1 = 0xFA;
 195   1        TL1 = 0xCB;
 196   1        IE |= 0x08;               //´ò¿ªT1ÖÐ¶Ï
 197   1        TCON |= 0x40;             //Ê¹ÄÜT1
 198   1          
 199   1        
 200   1          
 201   1        TH0 = 0xCB;
 202   1        TL0 = 0xEB;               //T0¶¨Ê±Ê±¼ä10ms
 203   1        
 204   1        TCON |= 0x10;             //Ê¹ÄÜT0
 205   1      }
 206          
 207          /***************************************************************************************
 208            * @ËµÃ÷   UART1³õÊ¼»¯º¯Êý
 209            * @²ÎÊý   ÎÞ
 210            * @·µ»ØÖµ ÎÞ
 211            * @×¢     ÎÞ
 212          ***************************************************************************************/
 213          void UART1_Init()
 214          {
 215   1        /**********************************UARTÅäÖÃ³õÊ¼»¯**************************************/
 216   1        P2M0 = P2M0&0xF0|0x08;              //P20ÉèÖÃÎªÍÆÍìÊä³ö
 217   1        P0M2 = P0M2&0xF0|0x02;              //P04ÉèÖÃÎªÉÏÀ­ÊäÈë
 218   1        P0_4 = 1;
 219   1        TXD_MAP = 0x20;                     //TXDÓ³ÉäP20
 220   1        RXD_MAP = 0x04;                     //RXDÓ³ÉäP04    
 221   1        T4CON = 0x06;                       //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
 222   1        
 223   1        //²¨ÌØÂÊ¼ÆËã
 224   1        //²¨ÌØÂÊ = 1/16 * (T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) / (65536 - 0xFF98)
 225   1        //       = 1/16 * ((16000000 / 1) / 104)
 226   1        //     = 9615.38(Îó²î0.16%)
 227   1      
 228   1        //²¨ÌØÂÊ9600
 229   1        //·´ÍÆ³õÖµ = (65536 - ((T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) * (1 / 16)) / ²¨ÌØÂÊ)
 230   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
 231   1        //       = (65536 - 104.167)
 232   1        //         = FF98
 233   1        //0xFF98->9600
 234   1        //0xFFCC->19200
 235   1        //0xFFEF->57600
 236   1        
 237   1        
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 5   

 238   1        TH4 = 0xFF;
 239   1        TL4 = 0x98; //²¨ÌØÂÊ9600    //0xEE;       //²¨ÌØÂÊ56000
 240   1        SCON2 = 0x02;                        //8Î»UART£¬²¨ÌØÂÊ¿É±ä
 241   1        SCON = 0x10;                         //ÔÊÐí´®ÐÐ½ÓÊÕ
 242   1        IE |= 0X10;                          //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
 243   1        //EA = 1;                              //Ê¹ÄÜ×ÜÖÐ¶Ï
 244   1      }
 245          
 246          /***************************************************************************************
 247            * @ËµÃ÷   ADC³õÊ¼»¯º¯Êý
 248            * @²ÎÊý   ÎÞ
 249            * @·µ»ØÖµ ÎÞ
 250            * @×¢     ÎÞ
 251          ***************************************************************************************/
 252          void ADC_Init()
 253          {
 254   1        
 255   1        ADCC0 |= 0x03;            //²Î¿¼Ô´ÎªÄÚ²¿2V
 256   1        ADCC0 |= 0x80;              //´ò¿ªADC×ª»»µçÔ´
 257   1        Delay_us(20);           //ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 258   1        ADCC1 = 0x01;             //Ñ¡ÔñÍâ²¿Í¨µÀ1
 259   1        ADCC2 = 0x4B;         //8·ÖÆµ   //×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ-1MHZ//0X4B-8·ÖÆµ//0X49-4·ÖÆµ
 260   1      }
 261          
 262          /***************************************************************************************
 263            * @ËµÃ÷   IO¿Ú³õÊ¼»¯º¯Êý
 264            * @²ÎÊý   ÎÞ
 265            * @·µ»ØÖµ ÎÞ
 266            * @×¢     ÎÞ
 267          ***************************************************************************************/
 268          void GPIO_Init()
 269          {
 270   1        //P0M0·Ö¸ß4Î»ÓëµÍ4Î»£¬µÍ4Î»¿ØÖÆP00ÊäÈëÊä³ö£¬¸ß4Î»¿ØÖÆP01ÊäÈëÊä³ö£¬ÆäËûÒÔ´ËÀàÍÆ
 271   1        //P0M1¸ß4¿ØÖÆP03£¬µÍ4¿ØÖÆP02
 272   1        //P1M2¸ß4¿ØÖÆP15£¬µÍ4¿ØÖÆP14
 273   1        
 274   1      //  P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
 275   1      //  P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 276   1      //  P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 277   1      //  P0M3 = P0M3&0xF0|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
 278   1        
 279   1        #ifdef V11
                
                P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
                //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
              //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
                
                #endif
 294   1        
 295   1        #ifdef V10
                
                P0M0 = P0M0&0xF0|0x08;          //P00
                
                P0M0 = P0M0&0x0F|0x30;          //P01
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 6   

                P0M3 = P0M3&0x0F|0x30;          //P07
              //  P0M0 = P0M0&0x0F|0x80;          //P01
                
                P0M3 = P0M3&0xF0|0x08;          //P06
                
                #endif
 306   1        
 307   1        #ifdef V12
 308   1        
 309   1        P1M0 = P1M0&0xF0|0x08;          //P10ÉèÖÃÎªÍÆÍìÊä³ö
 310   1        
 311   1        P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 312   1        
 313   1        P2M1 = P2M1&0xF0|0x03;          //P22ÉèÖÃÎªÄ£ÄâÊäÈë 
 314   1        
 315   1        //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 316   1      //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
 317   1        
 318   1        //P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
 319   1        
 320   1        //P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
 321   1        
 322   1      //  P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
 323   1        
 324   1        #endif    
 325   1        
 326   1        
 327   1      }
 328          
 329          // u16 Read_ADC(u8 Channel)
 330          // {
 331          //  u16 ADC_Temp;
 332          //  ADCC1 = Channel;              //Ñ¡ÔñÍâ²¿Í¨µÀ1
 333          //   ADCC0 |= 0x40;         //Æô¶¯ADC×ª»»
 334          //  while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 335          //  ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 336          //  ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 337          //  return ADC_Temp;
 338          // }
 339          
 340          /***************************************************************************************
 341            * @ËµÃ÷   ÏµÍ³Ê±ÖÓ¼ÆÊýº¯Êý
 342            * @²ÎÊý   ÎÞ
 343            * @·µ»ØÖµ ÎÞ
 344            * @×¢     ÎÞ
 345          ***************************************************************************************/
 346          /*
 347          void System_Time_Cnt(void)
 348          {
 349              static u32 Timer1Count1 = 0;
 350              static u8 Timer1Count2 = 0;
 351              u32 Tampe = 1;
 352              if(Timer1_FLAG)              //1ms
 353              {
 354                  Timer1_FLAG = 0;
 355                  Timer1Count1 ++;
 356                  Tampe = Timer1Count1 % 10;
 357                  if(Tampe == 0)
 358                      Time_10mS_FLAG = 1;
 359                  Tampe = Timer1Count1 % 100;
 360                  if(Tampe == 0)
 361                      Time_100mS_FLAG = 1;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 7   

 362                  Tampe = Timer1Count1 % 200;
 363                  if(Tampe == 0)
 364                      Time_200mS_FLAG = 1;
 365                  Tampe = Timer1Count1 % 500;
 366                  if(Tampe == 0)
 367                      Time_500mS_FLAG = 1;
 368                  Tampe = Timer1Count1 % 1000;
 369                  if(Tampe == 0)
 370                      Time_1S_FLAG = 1;
 371                  Tampe = Timer1Count1 % 10000;
 372                  if(Tampe == 0)
 373                  {
 374                      Time_10S_FLAG = 1;
 375                      Timer1Count1 = 0;
 376                      Timer1Count2 ++;
 377                      Tampe = Timer1Count2 % 6;
 378                      if(Tampe == 0)
 379                          Time_1Min_FLAG = 1;
 380                      Tampe = Timer1Count2 % 60;
 381                      if(Tampe == 0)
 382                      {
 383                          Time_1H_FLAG = 1;
 384                          Timer1Count2 = 0;
 385                      }
 386                  }
 387              }
 388          }
 389          */
 390          
 391          /***************************************************************************************
 392            * @ËµÃ÷   ÏµÍ³ÈÎÎñ´¦Àíº¯Êý
 393            * @²ÎÊý   ÎÞ
 394            * @·µ»ØÖµ ÎÞ
 395            * @×¢     ÎÞ
 396          ***************************************************************************************/
 397          
 398          /*
 399          void System_Task(void)
 400          {
 401              u8 temp;
 402              if(Time_10mS_FLAG)
 403              {
 404                  Time_10mS_FLAG = 0;
 405                  //User TASK
 406                  
 407                  
 408                  //User TASK
 409                  if(Time_100mS_FLAG)
 410                  {
 411                      Time_100mS_FLAG = 0;
 412                      //User TASK
 413          
 414                  
 415                  
 416                      //User TASK
 417                  }
 418                  if(Time_200mS_FLAG)
 419                  {
 420                      Time_200mS_FLAG = 0;
 421                      //User TASK
 422          
 423                  
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 8   

 424                  
 425                      //User TASK
 426                  }
 427                  if(Time_500mS_FLAG)
 428                  {
 429                      Time_500mS_FLAG = 0;
 430                      //User TASK
 431                      AN1_Data = Read_ADC(0x01);
 432                    
 433                      //User TASK
 434                  }
 435                   if(Time_1S_FLAG)
 436                  {
 437                      Time_1S_FLAG = 0;
 438                      //User TASK
 439          
 440                      temp = 0xFF & (AN1_Data >> 8);
 441                      SBUF = temp;
 442                      while(!(SCON & 0x02));
 443                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 444                      temp = 0xFF & AN1_Data;
 445                      SBUF = temp;
 446                      while(!(SCON & 0x02));
 447                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 448                      P0_0 =~ P0_0; 
 449                      //User TASK
 450                      
 451                  }
 452                  if(Time_10S_FLAG)
 453                  {
 454                      Time_10S_FLAG = 0;
 455                      //User TASK
 456                      
 457          
 458                      //User TASK
 459                  }
 460                  if(Time_1Min_FLAG)
 461                  {
 462                      Time_1Min_FLAG = 0;
 463                      //User TASK
 464                  
 465                  
 466                  
 467                      //User TASK
 468                  }
 469                  if(Time_1H_FLAG)
 470                  {
 471                      Time_1H_FLAG = 0;
 472                      //User TASK
 473                  
 474                  
 475                  
 476                      //User TASK
 477                  }
 478              }
 479          }
 480          */
 481          
 482          void send_data(u8 d)
 483          {
 484   1          SBUF = d;
 485   1          while(!(SCON & 0x02));
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 9   

 486   1          SCON &=~ 0x02;
 487   1      }
 488          
 489          uchar read_ad(uchar ch)
 490          {
 491   1        u8 i;
 492   1        uint  ad_sum;
 493   1        
 494   1      //  switch (ch)
 495   1      //  {
 496   1      //    case 3:
 497   1      //      ADC_P16_AN3;
 498   1      //      break;
 499   1      //    case 4:
 500   1      //      ADC_P15_AN4;
 501   1      //      break;
 502   1      //    case 5:
 503   1      //      ADC_P14_AN5;
 504   1      //      break;
 505   1      //  }
 506   1        
 507   1        
 508   1      //  if(ch==3)
 509   1      //  {
 510   1      //    ADC_P16_AN3;
 511   1      //  }
 512   1      //  else if(ch==4)
 513   1      //  {
 514   1      //    ADC_P15_AN4;
 515   1      //  }
 516   1        
 517   1        ADCC1 = ch;             //Ñ¡ÔñÍâ²¿Í¨µÀ
 518   1        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 519   1        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 520   1        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 521   1        
 522   1        //ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ 
 523   1        
 524   1      //  delay_ms(1);
 525   1      //  
 526   1      //  ADC_TG; 
 527   1        Delay_us(100);
 528   1        
 529   1        ad_sum=0;
 530   1        //ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 531   1        
 532   1        
 533   1        for(i=0;i<16;i++)
 534   1        {
 535   2      //    ADC_TG; 
 536   2      //    while(ADC_IF==0){};
 537   2      //    //adc_data = ADC_DATA_RD();
 538   2      //      
 539   2      //    k=ADC_DH;
 540   2      //    k =k <<8;
 541   2      //    k+=ADC_DL;
 542   2      //      
 543   2      //    ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 544   2      //    ad_sum+=k;
 545   2            
 546   2      
 547   2          ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 10  

 548   2          while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 549   2          ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 550   2          ad_sum += ADCR;       //»ñÈ¡ADCµÄÖµ
 551   2          
 552   2          Delay_us(20);
 553   2        }
 554   1        
 555   1        //ADC_P14_AN5;
 556   1        ADCC1 =1;
 557   1        i=ad_sum>>8;
 558   1        
 559   1        Delay_us(100);
 560   1        return(i);
 561   1        
 562   1      }
 563          
 564          void set_var(void)
 565          {
 566   1        
 567   1        Flash_ReadArr(0X2f00,10,guc_Read_a);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 568   1        
 569   1        TH=guc_Read_a[0];
 570   1        TH<<=8;
 571   1        TH+=guc_Read_a[1];
 572   1        TH*=1000;
 573   1        if(TH<TH_LOW||TH>TH_HIGH)TH=TH_DEF;
 574   1        
 575   1          
 576   1        LIGHT_TH=guc_Read_a[2];
 577   1      
 578   1        if(LIGHT_TH==0)LIGHT_TH=LIGHT_TH0;
 579   1        else 
 580   1          if(LIGHT_TH==0XFE)LIGHT_TH=255;
 581   1      
 582   1        DELAY_NUM=guc_Read_a[3];
 583   1        DELAY_NUM<<=8;
 584   1        DELAY_NUM+=guc_Read_a[4];
 585   1        if(DELAY_NUM==0||DELAY_NUM>MAX_DELAY)DELAY_NUM=5;
 586   1        
 587   1        //DELAY_NUM<<=2;
 588   1        lightvalue=guc_Read_a[5];
 589   1        //if(lightvalue>100)lightvalue=10;
 590   1        XRBoffbrightvalue = lightvalue;
 591   1        
 592   1        lowlightDELAY_NUM = guc_Read_a[6];
 593   1        if(lowlightDELAY_NUM==0||lowlightDELAY_NUM>255)lowlightDELAY_NUM=1;
 594   1        
 595   1        SWITCHfXBR = guc_Read_a[7]&0x01;
 596   1      //  addr = guc_Read_a[7];
 597   1      //  
 598   1      //  devgroup = guc_Read_a[8];
 599   1      
 600   1      //  addrend = guc_Read_a[9];
 601   1        
 602   1        Flash_ReadArr(0X2f80,1,guc_Read_a1);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 603   1        resetbtcnt = guc_Read_a1[0];
 604   1      }
 605          
 606          
 607          void XBRHandle(void)
 608          {
 609   1        u8 i,j;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 11  

 610   1        u16 k;
 611   1      //    if(while_1flag==0)
 612   1      //    send_data(0x55);
 613   1          //while(1)
 614   1          if(while_1flag==0)
 615   1          {
 616   2            //send_data(0x66);
 617   2      //        ADC_TG; 
 618   2      //        while(ADC_IF==0){};
 619   2      //        //adc_data = ADC_DATA_RD();
 620   2      //          
 621   2      //        k = ADC_DH<<8;
 622   2      //        //adc_data =adc_data <<8;
 623   2      //        k+= ADC_DL;
 624   2      //          
 625   2      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 626   2      
 627   2            ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 628   2            while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 629   2            ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 630   2            k = ADCR;       //»ñÈ¡ADCµÄÖµ
 631   2            
 632   2            times++;
 633   2            
 634   2            SUM+=k;
 635   2      
 636   2            //¼ÆËãÐÅºÅÖµÓëÖ±Á÷µçÑ¹Æ«²îÖµ
 637   2            if(k>average){k-=average;}
 638   2            else {k=average-k;}
 639   2            SUM1+=k;
 640   2      
 641   2            if((times&0x1ff)==0)
 642   2            {
 643   3              if(LIGHT>0) //????
 644   3              {
 645   4                
 646   4                //LIGHT++;
 647   4                
 648   4                if(slowchcnt<100)
 649   4                {
 650   5                  slowchcnt = slowchcnt+2;//
 651   5                  if(slowchcnt>100)
 652   5                  {
 653   6                    slowchcnt = 100;
 654   6                  }
 655   5                }
 656   4                PWM3init(slowchcnt);
 657   4              }
 658   3              else if((SWITCHflag2==0)&&(LIGHT_off ==1))
 659   3              {
 660   4                if(slowchcnt>lightvalue)
 661   4                {
 662   5                  if(slowchcnt>=2)slowchcnt-=2;
 663   5                  if(slowchcnt<lightvalue)slowchcnt=lightvalue;
 664   5                }
 665   4                PWM3init(slowchcnt);
 666   4              }
 667   3            }
 668   2            
 669   2            if(times>=8192) //250ms   //12800)  //330ms
 670   2            {
 671   3      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 12  

 672   3              WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 673   3              
 674   3              times=0;
 675   3      
 676   3              calc_average_times++;
 677   3            
 678   3              SUM16+=SUM;
 679   3              
 680   3              if(calc_average_times>=8) //Ã¿2.5SÖØÐÂ¼ÆËãÒ»´ÎÖ±Á÷µçÑ¹Öµ
 681   3              {
 682   4                calc_average_times=0;
 683   4                
 684   4                SUM16>>=16;
 685   4                //SUM16/=96000;//102400;
 686   4                average+=SUM16;
 687   4                average/=2;
 688   4                SUM16=0;
 689   4              }
 690   3              
 691   3              if(check_light_times<8) //2s  ¶ÁÈ¡Ò»´Î¸Ð¹âADÖµ
 692   3              {
 693   4                check_light_times++;
 694   4              }
 695   3              else
 696   3              {
 697   4                if(LIGHT==0)  
 698   4                {
 699   5                  //light_ad=READ_LIGHT();
 700   5                  light_ad=read_ad(10);
 701   5      
 702   5                  if((light_ad<=(light_ad0+2))&&(light_ad0<=(light_ad+2)))
 703   5                    light_ad=light_ad0;
 704   5      
 705   5                  light_ad0=light_ad;
 706   5      
 707   5                  check_light_times=0;
 708   5                }
 709   4              }
 710   3      
 711   3              if(SUM0==0)
 712   3              {
 713   4                SUM0=SUM1+5000; 
 714   4                if(start_times==0&&SUM0>1000000)SUM0=1000000;
 715   4              }
 716   3      
 717   3              if(SUM1_counter==0)
 718   3              {
 719   4                SUM10=SUM1;
 720   4                MAX_DELTA=1;//SUM10>>3;   
 721   4                //if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 722   4              }
 723   3              
 724   3                if((SUM10<(SUM1+MAX_DELTA))&&(SUM1<(SUM10+MAX_DELTA)))//???????????
 725   3                {
 726   4                  SUM1_counter++;
 727   4                  ALL_SUM1+=SUM1;
 728   4                  SUM10=ALL_SUM1/SUM1_counter;
 729   4                  MAX_DELTA=SUM10>>3;
 730   4                  if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 731   4                  if(MAX_DELTA>MAX_DELTA1)MAX_DELTA=MAX_DELTA1;
 732   4                  
 733   4                  if(SUM0>SUM10)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 13  

 734   4                  {
 735   5                    SUM=SUM0-SUM10;
 736   5                    if(SUM>80000)SUM0_num=6;
 737   5                    else if(SUM>40000)SUM0_num=9;
 738   5                    else SUM0_num=12;
 739   5                  }
 740   4                  else
 741   4                  {
 742   5                    SUM0_num=12;
 743   5                  }
 744   4                  
 745   4                  if((SUM1_counter>=SUM0_num)&&(SUM10<SUM0))
 746   4                  {
 747   5                    if(SUM1_num>16) //???????????????
 748   5                    {
 749   6                      if(SUM0_num<=9)SUM0=SUM10;
 750   6                      else if(SUM0>(SUM10+4000))
 751   6                      {
 752   7                        SUM0+=SUM10;
 753   7                        SUM0/=2;
 754   7                      }
 755   6                      SUM1_counter=0;
 756   6                      ALL_SUM1=0;
 757   6                    }
 758   5                  }
 759   4      
 760   4                  else if(SUM1_counter>=SUM1_num)
 761   4                  {
 762   5                    
 763   5      //              if(SUM0>SUM10)
 764   5      //              {
 765   5      //                if(SUM1_num>16)SUM0=SUM10;  //???????????????
 766   5      //              }
 767   5      //              else 
 768   5                      
 769   5                    if(SUM10>(SUM0+4000))
 770   5                    {
 771   6                      SUM=SUM10-SUM0;
 772   6      
 773   6                      if((SUM10<8000000)&&(SUM<400000))
 774   6          //????????????,???????????????100000?,???????
 775   6                      {
 776   7                        if(SUM1_num>16) //????????????
 777   7                        {
 778   8                          SUM0+=SUM10;
 779   8                          SUM0/=2;
 780   8                        }
 781   7                        else
 782   7                        {
 783   8                          if(SUM>300000)SUM1_num=16;
 784   8                          else if(SUM>150000)SUM1_num=12;
 785   8                          else SUM1_num=8;
 786   8                          if(SUM1_counter>=SUM1_num)
 787   8                          {
 788   9                            SUM0+=SUM10;
 789   9                            SUM0/=2;
 790   9                          }
 791   8                        }
 792   7                      }
 793   6                    }
 794   5      //              else if((LIGHT>0)&&(TH==TH_LOW))
 795   5      //              {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 14  

 796   5      //                SUM=SUM10-SUM0; 
 797   5      //                TH+=SUM;    //?????????????
 798   5      //              }
 799   5      
 800   5                    if(SUM1_counter>=SUM1_num)
 801   5                    {
 802   6                      SUM1_counter=0;
 803   6                      ALL_SUM1=0;
 804   6                    }
 805   5                  }
 806   4                }
 807   3                else
 808   3                {
 809   4                  SUM1_counter=0;
 810   4                  ALL_SUM1=0;
 811   4                }
 812   3      
 813   3      
 814   3      //        //send_byte=0x35;
 815   3      //        check_sum=0xFa;
 816   3              //send_data(0xFa);
 817   3      
 818   3      //        send_byte=TH>>15;
 819   3      //        check_sum+=send_byte;
 820   3      //        send_data(send_byte);
 821   3      
 822   3      //        //k=TH;
 823   3      //        send_byte=TH>>10;
 824   3      //        check_sum+=send_byte;
 825   3      //        send_data(send_byte);
 826   3      //          
 827   3      //        send_byte=LIGHT_TH;
 828   3      //        check_sum+=send_byte;
 829   3      //        send_data(send_byte);         
 830   3      
 831   3      //        //send_byte=light_ad;
 832   3      //        check_sum+=light_ad;
 833   3      //        send_data(light_ad);
 834   3      
 835   3      //        send_byte=average>>4;
 836   3      //        check_sum+=send_byte;
 837   3      //        send_data(send_byte);
 838   3      
 839   3      //        send_byte=SUM0>>16;
 840   3      //        check_sum+=send_byte;
 841   3      //        send_data(send_byte);
 842   3      
 843   3      //        send_byte=SUM0>>8;
 844   3      //        check_sum+=send_byte;
 845   3      //        send_data(send_byte);
 846   3      
 847   3      //        send_byte=SUM1>>16;
 848   3      //        check_sum+=send_byte;
 849   3      //        send_data(send_byte);
 850   3      
 851   3      //        send_byte=SUM1>>8;
 852   3      //        check_sum+=send_byte;
 853   3      //        send_data(send_byte);
 854   3      
 855   3      //        check_sum+=1;
 856   3      //        send_data(check_sum);
 857   3      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 15  

 858   3              if(stop_times>0)  //
 859   3              {
 860   4                stop_times--; 
 861   4                if((SUM0>(SUM01+6000))&&(SUM1<(SUM01+15000)))SUM0=SUM01+6000;
 862   4              }
 863   3              else
 864   3              {
 865   4              
 866   4                if(start_times>0)
 867   4                {
 868   5                  start_times--;
 869   5                  
 870   5                  if(start_times>0) //???????????,???????250*88ms=22S?????????          
 871   5                  {
 872   6                    //start_times++;
 873   6      /*
 874   6                    if(SUM0>600000)
 875   6                    {
 876   6                      TH=10000;
 877   6                    }
 878   6                    else */
 879   6                    if(SUM0>8000000)
 880   6                    {
 881   7                      TH=800000;
 882   7                    }
 883   6                    else
 884   6                    {
 885   7                      SUM=SUM0+TH;
 886   7                      if(SUM>9000000)
 887   7                      {
 888   8                        TH=9000000-SUM0;
 889   8                      }
 890   7                      //if(TH<30000)TH=30000;
 891   7                    }
 892   6      
 893   6                  }
 894   5                  else
 895   5                  {
 896   6                    //TH=TH_LOW;
 897   6                    //start_times=0;
 898   6      //              EA=0;
 899   6      //              set_var();
 900   6      //              EA=1;
 901   6                  }
 902   5      
 903   5                }
 904   4      
 905   4                if(SUM1>(SUM0+TH))
 906   4                {
 907   5                  //SUM=SUM1-SUM0;
 908   5      
 909   5                //  if(SUM>TH)
 910   5                //  {
 911   5                    if((light_ad<=LIGHT_TH)||(start_times>0))
 912   5                    {
 913   6      //                send_data(0xaa);
 914   6      
 915   6                      
 916   6                      //if(alarm_times<2)
 917   6                      //{
 918   6                      //  alarm_times++;
 919   6                    //    }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 16  

 920   6                      //if(alarm_times>=2)  //??????????????
 921   6                      {
 922   7                        if(LIGHT==0)SUM01=SUM0;
 923   7                        LIGHT=1;
 924   7                    
 925   7                        //PC3=0;
 926   7                        LIGHT_ON;
 927   7                        //slowchcnt = slowchcnt+20;//
 928   7                        //if(slowchcnt>100)
 929   7                        //{
 930   7                        //  slowchcnt = 100;
 931   7                        //}
 932   7                        //PWM3init(slowchcnt);
 933   7                        //P0_6=0;
 934   7      //                  send_data(0xaa);
 935   7      //                  send_data((TH/1000)>>8);
 936   7      //                  send_data((TH/1000)&0xff);
 937   7      //                  send_data(LIGHT_TH);
 938   7      //                  send_data(DELAY_NUM>>10);
 939   7      //                  send_data(DELAY_NUM>>2);    //²âÊÔÓÃ
 940   7      //                  send_data(slowchcnt);
 941   7      //                  send_data(0xaa);  
 942   7                        send_data(0xdd);
 943   7      
 944   7                        SUM1_num=8;
 945   7                        LIGHT_off=0;
 946   7                        light1scount=0;
 947   7                        light1sflag=0;
 948   7        //                send_data(0xaa);
 949   7      
 950   7                      }
 951   6                    }
 952   5                
 953   5                  }
 954   4      
 955   4              }
 956   3      
 957   3              SUM2=SUM1;
 958   3              send_data(average>>4);
 959   3              send_data(light_ad);
 960   3              send_data(SUM0>>16);
 961   3              send_data(SUM0>>8);
 962   3              send_data(SUM2>>16);
 963   3              send_data(SUM2>>8);     //20200927  ²âÊÔÓÃ        
 964   3              
 965   3              SUM=0;
 966   3              SUM1=0;
 967   3              
 968   3              if(LIGHT>0) //????
 969   3              {
 970   4                
 971   4                //LIGHT++;
 972   4                
 973   4      //          slowchcnt = slowchcnt+5;//
 974   4      //          if(slowchcnt>=100)
 975   4      //          {
 976   4      //            slowchcnt = 100;
 977   4      //          }
 978   4      //          PWM3init(slowchcnt);
 979   4                
 980   4                if(LIGHT>DELAY_NUM)
 981   4                {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 17  

 982   5                  LIGHT=0;
 983   5                  while_1flag=1;
 984   5                  //while_2flag = 0;
 985   5                  //break;
 986   5                }
 987   4              }
 988   3              
 989   3              
 990   3            }
 991   2      
 992   2      
 993   2          }
 994   1          else
 995   1          {
 996   2              LIGHT_off = 1;
 997   2              while_1flag=0;
 998   2              //if(while_2flag==0)
 999   2              //{
1000   2              //  while_2flag = 1;
1001   2      //          send_data(0x55);
1002   2              //}
1003   2              //PC3=1;
1004   2              LIGHT_OFF;
1005   2              //slowchcnt = lightvalue;
1006   2              //PWM3init(lightvalue);
1007   2              lowlight1mincount = 0;
1008   2              lowlight1minflag = 0;
1009   2              
1010   2            
1011   2              //P0_6=1;
1012   2              //send_data(0x55);
1013   2              Delay_ms(250);
1014   2      
1015   2      
1016   2              
1017   2          //    SUM=0;
1018   2          //    SUM1=0;
1019   2          //    times=0;
1020   2              
1021   2              SUM16=0;
1022   2              calc_average_times=0;
1023   2              SUM1_num=64;
1024   2              
1025   2              stop_times=2;
1026   2              //if(start_times==0)TH=TH_LOW;
1027   2              check_light_times=6;
1028   2              
1029   2              SUM1_counter=0;
1030   2              ALL_SUM1=0;
1031   2      
1032   2          //    send_data(0xdd);
1033   2          //    send_data(0xdd);
1034   2          }
1035   1      
1036   1      }
*** WARNING C280 IN LINE 609 OF ..\User\HC-MCU-XBR.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 609 OF ..\User\HC-MCU-XBR.c: 'j': unreferenced local variable
1037          
1038          
1039          void wait1(void)
1040          {
1041   1        u8 i,j;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 18  

1042   1      
1043   1        //µÈ´ýÖ±Á÷µçÑ¹ÎÈ¶¨
1044   1        j=0;
1045   1        while(1)
1046   1        {
1047   2          SUM=0;
1048   2          
1049   2          
1050   2      //    for(i=0;i<4;i++)  //0.52s
1051   2      //    {
1052   2      //      for(t=0;t<8192;t++) //0.13s
1053   2      //      {
1054   2      
1055   2      //        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1056   2      //        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1057   2      //        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1058   2      //        k = ADCR;       //»ñÈ¡ADCµÄÖµ
1059   2      //        
1060   2      //        SUM+=k;
1061   2      //  
1062   2      //      }
1063   2      //      
1064   2      //      WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1065   2            
1066   2      
1067   2            for(i=0;i<128;i++)  //
1068   2            {
1069   3      
1070   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1071   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1072   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1073   3              //k = ADCR;       //»ñÈ¡ADCµÄÖµ
1074   3              
1075   3              SUM+=ADCR;
1076   3              
1077   3            }
1078   2      
1079   2      //·¢ËÍ¸Ð¹âADÖµ
1080   2      //        send_byte=0xFA;
1081   2      //        check_sum=send_byte;
1082   2      //        send_data(send_byte);
1083   2      
1084   2      //        //send_byte=light_ad;
1085   2      //        check_sum+=light_ad;
1086   2      //        send_data(light_ad);
1087   2      
1088   2      //        check_sum+=light_ad;
1089   2      //        send_data(light_ad);
1090   2      //        
1091   2      //        check_sum+=1;
1092   2      //        send_data(check_sum);
1093   2      
1094   2      
1095   2      
1096   2        //}
1097   2          
1098   2          Delay_ms(400);
1099   2            
1100   2      
1101   2          
1102   2          //WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1103   2      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 19  

1104   2          i=SUM>>11;
1105   2          if((i>12)&&(i<141)&&(j>20))break;
1106   2      
1107   2          j++;
1108   2      
1109   2          if(j>80)break;  //??35????????????1.1V???????
1110   2      
1111   2        }
1112   1      }
1113          void wait2(void)
1114          {
1115   1        u8 i,j;
1116   1        u16 k,t;
1117   1      
1118   1        SUM=0;
1119   1      
1120   1      
1121   1          for(i=0;i<8;i++)
1122   1          {
1123   2            for(t=0;t<8192;t++) 
1124   2            {
1125   3      //        ADC_TG; 
1126   3      //        while(ADC_IF==0){};
1127   3      //        //adc_data = ADC_DATA_RD();
1128   3      //          
1129   3      //        k = ADC_DH<<8;
1130   3      //        //adc_data =adc_data <<8;
1131   3      //        k+= ADC_DL;
1132   3      //          
1133   3      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
1134   3          
1135   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1136   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1137   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1138   3              k = ADCR;       //»ñÈ¡ADCµÄÖµ
1139   3              
1140   3              SUM+=k;
1141   3        
1142   3            }
1143   2            WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1144   2      
1145   2          }
1146   1      
1147   1          average=SUM>>16;
1148   1      
1149   1      
1150   1      //  light_ad=read_ad(10);
1151   1      //  light_ad0=light_ad;
1152   1      
1153   1      //  Delay_ms(4);  //4ms
1154   1      }
*** WARNING C280 IN LINE 1115 OF ..\User\HC-MCU-XBR.c: 'j': unreferenced local variable
1155          
1156          unsigned char PWM3init(unsigned char ab)
1157          {
1158   1         float i11;
1159   1        unsigned char j11;
1160   1        i11=ab*255/100;
1161   1        j11=i11;
1162   1        #ifdef V11
              /************************************PWM3³õÊ¼»¯****************************************/
                //P0M3 = P0M3&0xF0|0x08;    //P06ÉèÖÃÎªÍÆÍìÊä³ö
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 20  

                PWM3_MAP = 0x05;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1168   1        
1169   1        #ifdef V10
                PWM3_MAP = 0x06;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1173   1      
1174   1        #ifdef V12
1175   1        PWM3_MAP = 0x10;          //PWM3Ó³ÉäP10¿Ú
1176   1        
1177   1        #endif  
1178   1        
1179   1          //ÖÜÆÚ¼ÆËã  = 0xFF / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1180   1        //      = 0xFF /(16000000 / 4)      
1181   1        //      = 255 /4000000
1182   1        //      = 63.75us   ¼´15.69KHZ    
1183   1      
1184   1        PWM3P = 0xFF;             //PWMÖÜÆÚÎª0xFF
1185   1        //ÓÐÐ§µçÆ½Ê±¼ä¼ÆËã£¨¼´Õ¼¿Õ±È£©  
1186   1        //      = 0x55 / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1187   1        //      = 0x55 /(16000000 / 4)      
1188   1        //      = 85 /4000000
1189   1        //      = 21.25us   Õ¼¿Õ±ÈÎª 21.25 / 63.75 = 34%
1190   1      
1191   1        PWM3D = j11;              //PWMÕ¼¿Õ±ÈÉèÖÃ
1192   1        PWM3C = 0x94;             //Ê¹ÄÜPWM3£¬¹Ø±ÕÖÐ¶Ï£¬ÔÊÐíÊä³ö£¬Ê±ÖÓ16·ÖÆµ
1193   1      }
*** WARNING C173 IN LINE 1193 OF ..\User\HC-MCU-XBR.c: missing return-expression
1194          
1195          /***************************************************************************************
1196            * @ËµÃ÷   Ö÷º¯Êý
1197            * @²ÎÊý   ÎÞ
1198            * @·µ»ØÖµ ÎÞ
1199            * @×¢     ÎÞ
1200          ***************************************************************************************/
1201          void main()
1202          {
1203   1        u8 i,j;
1204   1        bt_protocol_init();
1205   1        InitSYS();
1206   1        GPIO_Init();
1207   1        LIGHT_ON;
1208   1        //P0_6=0;
1209   1        PWM3init(100);
1210   1        Timer_Init();
1211   1        UART1_Init();
1212   1        ADC_Init();
1213   1      
1214   1        LVDC = 0xAA;              //LVDÉèÖÃ2.4V,½ûÖ¹ÖÐ¶Ï
1215   1        //  Ïû¶¶Ê±¼ä =  (0xFF + 2) * 1/Fcpu
1216   1        //       =  (0xFF + 2) / 16000000 £¨µ±Ç°µÄCPUÊ±ÖÓ£©
1217   1        //       =  16.0625us
1218   1        LVDDBC = 0xFF;            //ÉèÖÃÏû¶¶Ê±¼ä
1219   1        LVDC &=~ 0x08;            //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»   
1220   1      //  
1221   1        EA=1;
1222   1        
1223   1        Delay_ms(200);
1224   1        
1225   1        LIGHT_ON;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 21  

1226   1        PWM3init(100);
1227   1        SWITCHflag = 1;
1228   1        light_ad=read_ad(10);
1229   1        light_ad0=light_ad;
1230   1        
1231   1        EA=0;
1232   1        set_var();
1233   1        
1234   1        //for(i=0;i<5;i++)send_data(guc_Read_a[i]);
1235   1        
1236   1      //  TXdata[0]=VERSION;
1237   1      //  t=TH/1000;
1238   1      //  TXdata[1]=t>>8;
1239   1      //  TXdata[2]=t;
1240   1      //  TXdata[3]=LIGHT_TH;
1241   1      //  t=DELAY_NUM/4;
1242   1      //  TXdata[4]=t>>8;
1243   1      //  TXdata[5]=t;
1244   1      
1245   1      //  TXdata[6]=light_ad;
1246   1      
1247   1      //  for(i=0;i<7;i++)send_data(TXdata[i]); 
1248   1        resetbtcnt++;
1249   1        
1250   1        Flash_EraseBlock(0X2F80);
1251   1        Delay_us_1(10000);
1252   1        FLASH_WriteData(resetbtcnt,0X2F80);
1253   1        Delay_us_1(100);
1254   1        
1255   1        EA=1;
1256   1        
1257   1      
1258   1        wait1();
1259   1      
1260   1        slowchcnt = lightvalue;
1261   1        //Delay_ms(200);
1262   1        PWM3init(lightvalue);
1263   1        LIGHT_OFF;
1264   1        //P0_6=1;
1265   1        Delay_ms(300);
1266   1        
1267   1        wait2();
1268   1      
1269   1        SUM=0;
1270   1        while(1)
1271   1        {
1272   2          if(resetbtcnt>=3)
1273   2          {
1274   3            resetbtcnt = 0;
1275   3            send_data(0x55);
1276   3            send_data(0xAA);
1277   3            send_data(0X00);
1278   3            send_data(0X04);
1279   3            send_data(0X00);
1280   3            send_data(0X00);
1281   3            send_data(0X03);
1282   3            
1283   3          }
1284   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1285   2          bt_uart_service();
1286   2          
1287   2          if(SWITCHfXBR==1)//À×´ï¿ª
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 22  

1288   2          {
1289   3            if(while_2flag==0)
1290   3            {
1291   4              while_1flag=0;
1292   4      
1293   4              while_2flag = 1;
1294   4              slowchcnt = lightvalue;
1295   4      
1296   4              
1297   4              SUM16=0;
1298   4              calc_average_times=0;
1299   4              SUM1_num=64;
1300   4              
1301   4              stop_times=2;
1302   4              //if(start_times==0)TH=TH_LOW;
1303   4              check_light_times=6;
1304   4              
1305   4              SUM1_counter=0;
1306   4              ALL_SUM1=0;
1307   4            }
1308   3            
1309   3            XBRHandle();
1310   3            
1311   3            if(LIGHT_off>0)//¹ØµÆÑÓÊ±
1312   3            {
1313   4              if(lowlight1minflag==1)
1314   4              {
1315   5                lowlight1minflag = 0;
1316   5                LIGHT_off++;
1317   5                if(LIGHT_off>=lowlightDELAY_NUM)
1318   5                {
1319   6                  LIGHT_off=0;
1320   6                  PWM3init(0);
1321   6      
1322   6                }
1323   5              }
1324   4            }
1325   3            if(LIGHT>0)//ÁÁµÆÑÓÊ±
1326   3            {
1327   4              if(light1sflag==1)
1328   4              {
1329   5                light1sflag = 0;
1330   5                LIGHT++;
1331   5                //slowchcnt = slowchcnt+20;//
1332   5      //          if(slowchcnt>100)
1333   5      //          {
1334   5      //            slowchcnt = 100;
1335   5      //          }
1336   5      //          PWM3init(slowchcnt);
1337   5              }
1338   4            }
1339   3            
1340   3          }
1341   2          else
1342   2          {//À×´ï¹Ø
1343   3            while_2flag = 0;
1344   3            if(SWITCHflag2==0)//¹ØµÆ
1345   3            {
1346   4              PWM3init(0);
1347   4            }
1348   3            else
1349   3            {//¹ØµÆ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 23  

1350   4              PWM3init(XRBoffbrightvalue);
1351   4              
1352   4              while_1flag=0;
1353   4      
1354   4              slowchcnt = lightvalue;
1355   4              //PWM3init(lightvalue);
1356   4      
1357   4              
1358   4              SUM16=0;
1359   4              calc_average_times=0;
1360   4              SUM1_num=64;
1361   4              
1362   4              stop_times=2;
1363   4              //if(start_times==0)TH=TH_LOW;
1364   4              check_light_times=6;
1365   4              
1366   4              SUM1_counter=0;
1367   4              ALL_SUM1=0;
1368   4              
1369   4            }
1370   3            
1371   3          
1372   3          }
1373   2      
1374   2        } 
1375   1        
1376   1      //  while(1)
1377   1      //  {
1378   1      //    System_Time_Cnt();
1379   1      //    System_Task();
1380   1      //    WDTC |= 0x10;              //Çå¹·
1381   1      //  }
1382   1      
1383   1        
1384   1        
1385   1      }
*** WARNING C280 IN LINE 1203 OF ..\User\HC-MCU-XBR.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 1203 OF ..\User\HC-MCU-XBR.c: 'j': unreferenced local variable
1386          
1387          /***************************************************************************************
1388            * @ËµÃ÷   T1ÖÐ¶Ï·þÎñº¯Êý
1389            * @²ÎÊý   ÎÞ
1390            * @·µ»ØÖµ ÎÞ
1391            * @×¢     ÎÞ
1392          ***************************************************************************************/
1393          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR
1394          {
1395   1        //Timer1_FLAG = 1;    //1mS
1396   1        Timer_Counter++;
1397   1      
1398   1        lowlight1mincount++;
1399   1        if(lowlight1mincount>=60000)
1400   1        {
1401   2          lowlight1mincount = 0;
1402   2          lowlight1minflag = 1;
1403   2        }
1404   1        light1scount++;
1405   1        if(light1scount>=1000)
1406   1        {
1407   2          light1scount=0;
1408   2          light1sflag=1;
1409   2        }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 24  

1410   1      
1411   1        
1412   1      }
1413          
1414          /***************************************************************************************
1415            * @ËµÃ÷   UART1ÖÐ¶Ï·þÎñº¯Êý
1416            * @²ÎÊý   ÎÞ
1417            * @·µ»ØÖµ ÎÞ
1418            * @×¢     ÎÞ
1419          ***************************************************************************************/
1420          
1421          void UART1_Rpt(void) interrupt UART1_VECTOR
1422          {
1423   1        u8 i;
1424   1        //u16 t;
1425   1        
1426   1        if(SCON & 0x01)                       //ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1427   1        {
1428   2            i=SBUF;
1429   2            uart_receive_input(i);
1430   2            SCON &=~ 0x01;                    //Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1431   2            EA=1;
1432   2        }
1433   1      }
1434          
1435          void UART2_Rpt(void) interrupt UART2_VECTOR
1436          {
1437   1      }
1438          
1439          // void Delay_2us(u16 Cnt)
1440          // {
1441          //  while(Cnt--); 
1442          // }
1443          
1444          void Flash_EraseBlock(unsigned int fui_Address)
1445          {
1446   1        while(1)
1447   1        {
1448   2          LVDC &=~ 0x08;        //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1449   2          P0_0=0;   
1450   2          if((LVDC&0x08)==0)    break;
1451   2        }
1452   1        P0_0=1;   
1453   1        EA=0;
1454   1        IAP_CMD = 0xF00F;       //Flash½âËø
1455   1        IAP_ADDR = fui_Address; //Ð´Èë²Á³ýµØÖ·
1456   1        IAP_CMD = 0xD22D;       //Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ý
1457   1        IAP_CMD = 0xE11E;       //´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
1458   1        //EA=1;
1459   1      }
1460          
1461          /**
1462            * @ËµÃ÷   Ð´ÈëÒ»¸ö×Ö½ÚÊý¾Ýµ½FlashÀïÃæ
1463            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1464            * @²ÎÊý   fui_Address £ºFLASHµØÖ·
1465            * @²ÎÊý   fucp_SaveData£ºÐ´ÈëµÄÊý¾Ý
1466            * @·µ»ØÖµ ÎÞ
1467            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1468            */
1469          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
1470          {
1471   1        while(1)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/06/2020 15:47:35 PAGE 25  

1472   1        {
1473   2          LVDC &=~ 0x08;         //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1474   2          P0_0=0;   
1475   2          if((LVDC&0x08)==0)    break;
1476   2        }
1477   1        P0_0=1; 
1478   1        EA=0;
1479   1        IAP_DATA = fuc_SaveData;
1480   1        IAP_CMD=0xF00F;          //Flash½âËø
1481   1        IAP_ADDR = fui_Address;
1482   1        IAP_CMD=0xB44B;          //×Ö½Ú±à³Ì
1483   1        IAP_CMD=0xE11E;          //´¥·¢Ò»´Î²Ù×÷
1484   1        //EA=1;
1485   1      }
1486          
1487          /**
1488            * @ËµÃ÷   Ð´ÈëÈÎÒâ³¤¶ÈµÄÊý¾Ýµ½FLASHÀïÃæ
1489            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1490            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1491            * @²ÎÊý   fuc_Length £º Ð´ÈëÊý¾Ý³¤¶È
1492            *         È¡Öµ·¶Î§£º0x00-0xFF
1493            * @²ÎÊý  *fucp_SaveArr£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
1494            * @·µ»ØÖµ ÎÞ
1495            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1496            */
1497          
1498          // void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
1499          // {
1500          //  unsigned char fui_i = 0;
1501          //  EA=0;
1502          //  for(fui_i=0;fui_i<fuc_Length;fui_i++)
1503          //  {
1504          //    FLASH_WriteData(*(fucp_SaveArr++), fui_Address++); 
1505          //  }
1506          //  EA=1;
1507          // }
1508          
1509          /**
1510            * @ËµÃ÷   ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊý¾Ý
1511            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1512            * @²ÎÊý   fuc_Length £º¶ÁÈ¡Êý¾Ý³¤¶È
1513            *         È¡Öµ·¶Î§£º0x00-0xFF
1514            * @²ÎÊý  *fucp_SaveArr£º¶ÁÈ¡Êý¾Ý´æ·ÅµÄÇøÓòÊ×µØÖ·
1515            * @·µ»ØÖµ ÎÞ
1516            * @×¢     ÎÞ
1517            */
1518          
*** WARNING C290 IN LINE 1193 OF ..\User\HC-MCU-XBR.c: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4232    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     91    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      19
   IDATA SIZE       =      4    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)

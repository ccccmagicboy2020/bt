C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HC_MCU_XBR
OBJECT MODULE PLACED IN .\Objects\HC-MCU-XBR.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\HC-MCU-XBR.c BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\HC-MCU-XBR.lst) TABS(2) OBJECT(.\Objects\HC-MCU-XBR.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89S003F4.h"
   3          //#include "Mcu_api.h"
   4          #include "bluetooth.h"
   5          
   6          #define V12
   7          //#define V10
   8          
   9          
  10          //#define  VERSION  0X21
  11          
  12          #define  TH_LOW   30000
  13          #define  TH_HIGH  4000000
  14          
  15          #define  TH_DEF   40000
  16            
  17          //ÔÊÐíÔëÉùÖµÆ«²î·¶Î§
  18          #define  MAX_DELTA0  20000
  19          #define  MAX_DELTA1  60000
  20          
  21          #define  MAX_DELAY  1800
  22          //×î´óÑÓÊ±ÃëÊý
  23          
  24          //¸Ð¹âÃÅÏÞ-30¶ÔÓ¦8LUX×óÓÒµÄADÖµ,ÉèÖÃÎª255±íÊ¾²»¼ì²â¸Ð¹â
  25          #define  LIGHT_TH0 255
  26          //30
  27          
  28          //Ò»¸ö¼ì²âÖÜÆÚÎª0.25Ãë
  29          //#define DELAY_NUM 20
  30          
  31          
  32          //#define LIGHT_ON P0_6=0
  33          //#define LIGHT_OFF P0_6=1
  34          
  35          //void Delay_2us(u16 Cnt);    //ÑÓÊ±º¯Êý
  36          
  37          // bit Timer1_FLAG;
  38          // bit Time_10mS_FLAG;
  39          // bit Time_100mS_FLAG;
  40          // bit Time_200mS_FLAG;
  41          // bit Time_500mS_FLAG;
  42          // bit Time_1S_FLAG;
  43          // bit Time_10S_FLAG;
  44          // bit Time_1Min_FLAG;
  45          // bit Time_1H_FLAG;
  46          
  47          volatile ulong Timer_Counter=0;
  48          
  49           //u8 Uart1_RX_Buff[10] = {0};           //ÓÃÓÚ´æ·ÅUART1½ÓÊÕÊý¾Ý
  50           //u8 Uart1_RX_Cnt = 0;                //UART1½ÓÊÕ¼ÆÊý
  51           //u8 Uart1_TX_Buff[20] = {0};           //ÓÃÓÚ´æ·ÅUART1·¢ËÍÊý¾Ý
  52           //u8 Uart1_TX_Cnt = 0;                //UART1·¢ËÍ¼ÆÊý
  53           
  54          // u16 AN1_Data = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 2   

  55          // u16 AN7_Data = 0;
  56          // u8 Uart_Cnt = 0;
  57          
  58          
  59            u8 xdata SUM1_counter=0,SUM1_num=64,SUM0_num=12;
  60            ulong xdata SUM1=0,SUM0=0,SUM=0,ALL_SUM1=0,SUM10=0,SUM16=0,SUM01,SUM2;
  61            u16   xdata times=0,start_times=1;
  62            ulong  xdata TH,MAX_DELTA;
  63            u8  xdata alarm_times=0,stop_times=0;
  64          
  65            uint  xdata average,LIGHT=0,LIGHT_off=0;
  66            u8  xdata light_ad,light_ad0,check_light_times=8,calc_average_times=0,check_sum,send_byte;
  67            u8  xdata LIGHT_TH;
  68            u16  xdata DELAY_NUM;
  69            u8 xdata lowlightDELAY_NUM;
  70            u8  xdata RXnum=0;
  71            u8 while_1flag = 0;
  72            u8 while_2flag = 0;
  73            u8 xdata  SWITCHflag = 0;
  74            u8 xdata  SWITCHflag2 = 0;
  75            u8 xdata  SWITCHfXBR = 1;
  76            u8      xdata lightvalue = 10;
  77            u8 xdata switchcnt = 0;
  78            u8 xdata slowchcnt = 10;
  79             u8 xdata resetbtcnt = 0;
  80             u8 xdata XRBoffbrightvalue = 0;
  81             volatile u16 xdata lowlight1mincount = 0;
  82             volatile u8 xdata  lowlight1minflag =0;
  83            volatile u16 idata light1scount  = 0;
  84            volatile u16 idata light1sflag = 0;
  85             u8 xdata addr = 0;
  86             u8 xdata devgroup = 0;
  87             u8 xdata addrend=0;
  88             u16 idata groupaddr[8] = {0};
  89             u8 idata check_group_flag = 0;
  90             u8 idata check_group_count = 0;
  91             u8 idata Linkage_flag  =0;
  92             u8 idata Light_on_flag = 0;
  93             u8 idata Light_on_flagpre = 0;
  94             
  95             /*
  96             u8 idata groupaddr2 = 0;
  97             u8 idata groupaddr3 = 0;
  98             u8 idata groupaddr4 = 0;
  99             u8 idata groupaddr5 = 0;
 100             u8 idata groupaddr6 = 0;
 101             u8 idata groupaddr7 = 0;
 102             u8 idata groupaddr8 = 0;
 103             */
 104           unsigned char PWM3init(unsigned char ab);
 105          void Flash_EraseBlock(unsigned int fui_Address);//ÉÈÇø²Á³ý
 106          //void FLASH_WriteData(unsigned char fui_Address, unsigned int fuc_SaveData);//Ð´ÈëÒ»¸öÊý¾Ý
 107          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);
 108          //void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//Ð´È
             -ëÈÎÒâ³¤¶ÈÊý¾Ý
 109          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//¶ÁÈ¡ÈÎ
             -Òâ³¤¶ÈÊý¾Ý
 110          
 111          //unsigned char guc_Write_a[5] = {0}; //Ð´ÈëÊý¾Ý
 112          unsigned char xdata guc_Read_a[10] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
 113          unsigned char xdata guc_Read_a1[1] = {0x00};      //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊý¾Ý
 114          // unsigned char guc_Uartflag = 0;            //·¢ËÍ±êÖ¾Î»
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 3   

 115          // unsigned char guc_Uartcnt = 0;           //·¢ËÍ¼ÆÊý
 116          // unsigned char guc_Uartbuf_a[2] = {0x00}; //»º´æÊý×é
 117          
 118          void Flash_ReadArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
 119          {
 120   1        while(fuc_Length--)
 121   1        *(fucp_SaveArr++)=*((unsigned char code *)(fui_Address++));//¶ÁÈ¡Êý¾Ý
 122   1      }
 123          
 124          void Delay_us(uint q)
 125          {
 126   1        uint j;
 127   1        for(j=0;j<q;j++)
 128   1        {
 129   2            ;
 130   2        }
 131   1      }
 132          
 133          void Delay_ms(uint t)
 134          {
 135   1        Timer_Counter=0;
 136   1        while(Timer_Counter<t)
 137   1        {
 138   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 139   2        }
 140   1        
 141   1      }
 142          
 143          void Delay_us_1(uint q1)
 144          {
 145   1        uint j;
 146   1        for(j=0;j<q1;j++)
 147   1        {
 148   2            ;
 149   2        }
 150   1      }
 151          
 152          
 153          
 154          // void Delay_ms(uint t)
 155          // {
 156          //  for(;t>0;t--)
 157          //  {
 158          //    Delay_us_1(1000);
 159          //    WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 160          //  }
 161          // }
 162          
 163          /***************************************************************************************
 164            * @ËµÃ÷   ÏµÍ³³õÊ¼»¯º¯Êý
 165            * @²ÎÊý   ÎÞ
 166            * @·µ»ØÖµ ÎÞ
 167            * @×¢     ÎÞ
 168          ***************************************************************************************/
 169          void InitSYS()
 170          {
 171   1        /********************************ÏµÍ³ÆµÂÊ³õÊ¼»¯***************************************/
 172   1        
 173   1        CLKSWR = 0x51;                     //Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
 174   1        CLKDIV = 0x01;                     //Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz 
 175   1        FREQ_CLK = 0x10;                   //IAPÆµÂÊ
 176   1        
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 4   

 177   1        /**********************************µÍÑ¹¸´Î»³õÊ¼»¯**************************************/
 178   1        
 179   1      //  BORC = 0xC0;                       //Ê¹ÄÜµÍÑ¹¸´Î»1.8V£¬´øÏû¶¶Ê¹ÄÜ
 180   1      //  BORDBC = 0x01;                     //Ïû¶¶Ê±¼äBORDBC*8TCPU+2TCPU
 181   1        
 182   1        /***********************************¿´ÃÅ¿Ú³õÊ¼»¯***************************************/
 183   1        WDTC = 0x5F;                       //ÔÊÐíWDT¸´Î»£¬¿ÕÏÐÄ£Ê½ÏÂ½ûÖ¹WDT£¬Ñ¡Ôñ1024·ÖÆµ£¨ÄÚ²¿µÍÆµÊ±ÖÓ44K£©
 184   1        WDTCCR = 0X20;  //0X20/44 =0.73Ãë           //0xFF;  //Òç³öÊ±¼äÔ¼6Ãë
 185   1        //Òç³ö¼ÆËãÊ±¼ä=£¨WDT·ÖÆµÏµÊý*£¨WDTCCR+1£©£©/ÄÚ²¿µÍÆµRCÆµÂÊ
 186   1      }
 187          
 188          /***************************************************************************************
 189            * @ËµÃ÷   ¶¨Ê±Æ÷³õÊ¼»¯º¯Êý
 190            * @²ÎÊý   ÎÞ
 191            * @·µ»ØÖµ ÎÞ
 192            * @×¢     ÎÞ
 193          ***************************************************************************************/
 194          void Timer_Init()
 195          {
 196   1        /**********************************TIM1ÅäÖÃ³õÊ¼»¯**************************************/
 197   1        TCON1 = 0x00;             //T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 198   1        TMOD = 0x01;              //T1-16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷,T0-16Î»¶¨Ê±Æ÷
 199   1      
 200   1        //Tim1¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊý))
 201   1        //        = 1333 / (16000000 / 12)
 202   1        //        = 1 ms
 203   1      
 204   1        //¶¨Ê±1ms
 205   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊý)))
 206   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 207   1        //      = 65536 - 1333
 208   1        //      = 0xFACB
 209   1        
 210   1        TH1 = 0xFA;
 211   1        TL1 = 0xCB;
 212   1        IE |= 0x08;               //´ò¿ªT1ÖÐ¶Ï
 213   1        TCON |= 0x40;             //Ê¹ÄÜT1
 214   1          
 215   1        
 216   1          
 217   1        TH0 = 0xCB;
 218   1        TL0 = 0xEB;               //T0¶¨Ê±Ê±¼ä10ms
 219   1        
 220   1        TCON |= 0x10;             //Ê¹ÄÜT0
 221   1      }
 222          
 223          /***************************************************************************************
 224            * @ËµÃ÷   UART1³õÊ¼»¯º¯Êý
 225            * @²ÎÊý   ÎÞ
 226            * @·µ»ØÖµ ÎÞ
 227            * @×¢     ÎÞ
 228          ***************************************************************************************/
 229          void UART1_Init()
 230          {
 231   1        /**********************************UARTÅäÖÃ³õÊ¼»¯**************************************/
 232   1        P2M0 = P2M0&0xF0|0x08;              //P20ÉèÖÃÎªÍÆÍìÊä³ö
 233   1        P0M2 = P0M2&0xF0|0x02;              //P04ÉèÖÃÎªÉÏÀ­ÊäÈë
 234   1        P0_4 = 1;
 235   1        TXD_MAP = 0x20;                     //TXDÓ³ÉäP20
 236   1        RXD_MAP = 0x04;                     //RXDÓ³ÉäP04    
 237   1        T4CON = 0x06;                       //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
 238   1        
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 5   

 239   1        //²¨ÌØÂÊ¼ÆËã
 240   1        //²¨ÌØÂÊ = 1/16 * (T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) / (65536 - 0xFF98)
 241   1        //       = 1/16 * ((16000000 / 1) / 104)
 242   1        //     = 9615.38(Îó²î0.16%)
 243   1      
 244   1        //²¨ÌØÂÊ9600
 245   1        //·´ÍÆ³õÖµ = (65536 - ((T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) * (1 / 16)) / ²¨ÌØÂÊ)
 246   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
 247   1        //       = (65536 - 104.167)
 248   1        //         = FF98
 249   1        //0xFF98->9600
 250   1        //0xFFCC->19200
 251   1        //0xFFEF->57600
 252   1        
 253   1        
 254   1        TH4 = 0xFF;
 255   1        TL4 = 0x98; //²¨ÌØÂÊ9600    //0xEE;       //²¨ÌØÂÊ56000
 256   1        SCON2 = 0x02;                        //8Î»UART£¬²¨ÌØÂÊ¿É±ä
 257   1        SCON = 0x10;                         //ÔÊÐí´®ÐÐ½ÓÊÕ
 258   1        IE |= 0X10;                          //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
 259   1        //EA = 1;                              //Ê¹ÄÜ×ÜÖÐ¶Ï
 260   1      }
 261          
 262          /***************************************************************************************
 263            * @ËµÃ÷   ADC³õÊ¼»¯º¯Êý
 264            * @²ÎÊý   ÎÞ
 265            * @·µ»ØÖµ ÎÞ
 266            * @×¢     ÎÞ
 267          ***************************************************************************************/
 268          void ADC_Init()
 269          {
 270   1        
 271   1        ADCC0 |= 0x03;            //²Î¿¼Ô´ÎªÄÚ²¿2V
 272   1        ADCC0 |= 0x80;              //´ò¿ªADC×ª»»µçÔ´
 273   1        Delay_us(20);           //ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 274   1        ADCC1 = 0x01;             //Ñ¡ÔñÍâ²¿Í¨µÀ1
 275   1        ADCC2 = 0x4B;         //8·ÖÆµ   //×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ-1MHZ//0X4B-8·ÖÆµ//0X49-4·ÖÆµ
 276   1      }
 277          
 278          /***************************************************************************************
 279            * @ËµÃ÷   IO¿Ú³õÊ¼»¯º¯Êý
 280            * @²ÎÊý   ÎÞ
 281            * @·µ»ØÖµ ÎÞ
 282            * @×¢     ÎÞ
 283          ***************************************************************************************/
 284          void GPIO_Init()
 285          {
 286   1        //P0M0·Ö¸ß4Î»ÓëµÍ4Î»£¬µÍ4Î»¿ØÖÆP00ÊäÈëÊä³ö£¬¸ß4Î»¿ØÖÆP01ÊäÈëÊä³ö£¬ÆäËûÒÔ´ËÀàÍÆ
 287   1        //P0M1¸ß4¿ØÖÆP03£¬µÍ4¿ØÖÆP02
 288   1        //P1M2¸ß4¿ØÖÆP15£¬µÍ4¿ØÖÆP14
 289   1        
 290   1      //  P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
 291   1      //  P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 292   1      //  P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 293   1      //  P0M3 = P0M3&0xF0|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
 294   1        
 295   1        #ifdef V11
                
                P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
                //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 6   

              //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
                
                P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
                
                #endif
 310   1        
 311   1        #ifdef V10
                
                P0M0 = P0M0&0xF0|0x08;          //P00
                
                P0M0 = P0M0&0x0F|0x30;          //P01
                P0M3 = P0M3&0x0F|0x30;          //P07
              //  P0M0 = P0M0&0x0F|0x80;          //P01
                
                P0M3 = P0M3&0xF0|0x08;          //P06
                
                #endif
 322   1        
 323   1        #ifdef V12
 324   1        
 325   1        P1M0 = P1M0&0xF0|0x08;          //P10ÉèÖÃÎªÍÆÍìÊä³ö
 326   1        
 327   1        P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 328   1        
 329   1        P2M1 = P2M1&0xF0|0x03;          //P22ÉèÖÃÎªÄ£ÄâÊäÈë 
 330   1        
 331   1        //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 332   1      //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
 333   1        
 334   1        //P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
 335   1        
 336   1        //P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
 337   1        
 338   1      //  P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë 
 339   1        
 340   1        #endif    
 341   1        
 342   1        
 343   1      }
 344          
 345          // u16 Read_ADC(u8 Channel)
 346          // {
 347          //  u16 ADC_Temp;
 348          //  ADCC1 = Channel;              //Ñ¡ÔñÍâ²¿Í¨µÀ1
 349          //   ADCC0 |= 0x40;         //Æô¶¯ADC×ª»»
 350          //  while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 351          //  ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 352          //  ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 353          //  return ADC_Temp;
 354          // }
 355          
 356          /***************************************************************************************
 357            * @ËµÃ÷   ÏµÍ³Ê±ÖÓ¼ÆÊýº¯Êý
 358            * @²ÎÊý   ÎÞ
 359            * @·µ»ØÖµ ÎÞ
 360            * @×¢     ÎÞ
 361          ***************************************************************************************/
 362          /*
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 7   

 363          void System_Time_Cnt(void)
 364          {
 365              static u32 Timer1Count1 = 0;
 366              static u8 Timer1Count2 = 0;
 367              u32 Tampe = 1;
 368              if(Timer1_FLAG)              //1ms
 369              {
 370                  Timer1_FLAG = 0;
 371                  Timer1Count1 ++;
 372                  Tampe = Timer1Count1 % 10;
 373                  if(Tampe == 0)
 374                      Time_10mS_FLAG = 1;
 375                  Tampe = Timer1Count1 % 100;
 376                  if(Tampe == 0)
 377                      Time_100mS_FLAG = 1;
 378                  Tampe = Timer1Count1 % 200;
 379                  if(Tampe == 0)
 380                      Time_200mS_FLAG = 1;
 381                  Tampe = Timer1Count1 % 500;
 382                  if(Tampe == 0)
 383                      Time_500mS_FLAG = 1;
 384                  Tampe = Timer1Count1 % 1000;
 385                  if(Tampe == 0)
 386                      Time_1S_FLAG = 1;
 387                  Tampe = Timer1Count1 % 10000;
 388                  if(Tampe == 0)
 389                  {
 390                      Time_10S_FLAG = 1;
 391                      Timer1Count1 = 0;
 392                      Timer1Count2 ++;
 393                      Tampe = Timer1Count2 % 6;
 394                      if(Tampe == 0)
 395                          Time_1Min_FLAG = 1;
 396                      Tampe = Timer1Count2 % 60;
 397                      if(Tampe == 0)
 398                      {
 399                          Time_1H_FLAG = 1;
 400                          Timer1Count2 = 0;
 401                      }
 402                  }
 403              }
 404          }
 405          */
 406          
 407          /***************************************************************************************
 408            * @ËµÃ÷   ÏµÍ³ÈÎÎñ´¦Àíº¯Êý
 409            * @²ÎÊý   ÎÞ
 410            * @·µ»ØÖµ ÎÞ
 411            * @×¢     ÎÞ
 412          ***************************************************************************************/
 413          
 414          /*
 415          void System_Task(void)
 416          {
 417              u8 temp;
 418              if(Time_10mS_FLAG)
 419              {
 420                  Time_10mS_FLAG = 0;
 421                  //User TASK
 422                  
 423                  
 424                  //User TASK
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 8   

 425                  if(Time_100mS_FLAG)
 426                  {
 427                      Time_100mS_FLAG = 0;
 428                      //User TASK
 429          
 430                  
 431                  
 432                      //User TASK
 433                  }
 434                  if(Time_200mS_FLAG)
 435                  {
 436                      Time_200mS_FLAG = 0;
 437                      //User TASK
 438          
 439                  
 440                  
 441                      //User TASK
 442                  }
 443                  if(Time_500mS_FLAG)
 444                  {
 445                      Time_500mS_FLAG = 0;
 446                      //User TASK
 447                      AN1_Data = Read_ADC(0x01);
 448                    
 449                      //User TASK
 450                  }
 451                   if(Time_1S_FLAG)
 452                  {
 453                      Time_1S_FLAG = 0;
 454                      //User TASK
 455          
 456                      temp = 0xFF & (AN1_Data >> 8);
 457                      SBUF = temp;
 458                      while(!(SCON & 0x02));
 459                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 460                      temp = 0xFF & AN1_Data;
 461                      SBUF = temp;
 462                      while(!(SCON & 0x02));
 463                      SCON &=~ 0x02;                 //Çå³ý·¢ËÍÖÐ¶Ï±êÖ¾Î»
 464                      P0_0 =~ P0_0; 
 465                      //User TASK
 466                      
 467                  }
 468                  if(Time_10S_FLAG)
 469                  {
 470                      Time_10S_FLAG = 0;
 471                      //User TASK
 472                      
 473          
 474                      //User TASK
 475                  }
 476                  if(Time_1Min_FLAG)
 477                  {
 478                      Time_1Min_FLAG = 0;
 479                      //User TASK
 480                  
 481                  
 482                  
 483                      //User TASK
 484                  }
 485                  if(Time_1H_FLAG)
 486                  {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 9   

 487                      Time_1H_FLAG = 0;
 488                      //User TASK
 489                  
 490                  
 491                  
 492                      //User TASK
 493                  }
 494              }
 495          }
 496          */
 497          
 498          void send_data(u8 d)
 499          {
 500   1          SBUF = d;
 501   1          while(!(SCON & 0x02));
 502   1          SCON &=~ 0x02;
 503   1      }
 504          
 505          uchar read_ad(uchar ch)
 506          {
 507   1        u8 i;
 508   1        uint  ad_sum;
 509   1        
 510   1      //  switch (ch)
 511   1      //  {
 512   1      //    case 3:
 513   1      //      ADC_P16_AN3;
 514   1      //      break;
 515   1      //    case 4:
 516   1      //      ADC_P15_AN4;
 517   1      //      break;
 518   1      //    case 5:
 519   1      //      ADC_P14_AN5;
 520   1      //      break;
 521   1      //  }
 522   1        
 523   1        
 524   1      //  if(ch==3)
 525   1      //  {
 526   1      //    ADC_P16_AN3;
 527   1      //  }
 528   1      //  else if(ch==4)
 529   1      //  {
 530   1      //    ADC_P15_AN4;
 531   1      //  }
 532   1        
 533   1        ADCC1 = ch;             //Ñ¡ÔñÍâ²¿Í¨µÀ
 534   1        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 535   1        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 536   1        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 537   1        
 538   1        //ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ 
 539   1        
 540   1      //  delay_ms(1);
 541   1      //  
 542   1      //  ADC_TG; 
 543   1        Delay_us(100);
 544   1        
 545   1        ad_sum=0;
 546   1        //ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 547   1        
 548   1        
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 10  

 549   1        for(i=0;i<16;i++)
 550   1        {
 551   2      //    ADC_TG; 
 552   2      //    while(ADC_IF==0){};
 553   2      //    //adc_data = ADC_DATA_RD();
 554   2      //      
 555   2      //    k=ADC_DH;
 556   2      //    k =k <<8;
 557   2      //    k+=ADC_DL;
 558   2      //      
 559   2      //    ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 560   2      //    ad_sum+=k;
 561   2            
 562   2      
 563   2          ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 564   2          while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 565   2          ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 566   2          ad_sum += ADCR;       //»ñÈ¡ADCµÄÖµ
 567   2          
 568   2          Delay_us(20);
 569   2        }
 570   1        
 571   1        //ADC_P14_AN5;
 572   1        ADCC1 =1;   //ÇÐ»»µ½an1
 573   1        i=ad_sum>>8;
 574   1        
 575   1        Delay_us(100);
 576   1        return(i);
 577   1        
 578   1      }
 579          
 580          void set_var(void)
 581          {
 582   1        
 583   1        Flash_ReadArr(0X2f00,10,guc_Read_a);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 584   1        
 585   1        TH=guc_Read_a[0];
 586   1        TH<<=8;
 587   1        TH+=guc_Read_a[1];
 588   1        TH*=1000;
 589   1        if(TH<TH_LOW||TH>TH_HIGH)TH=TH_DEF;
 590   1        
 591   1          
 592   1        LIGHT_TH=guc_Read_a[2];
 593   1      
 594   1        if(LIGHT_TH==0)LIGHT_TH=LIGHT_TH0;
 595   1        else 
 596   1          if(LIGHT_TH==0XFE)LIGHT_TH=255;
 597   1      
 598   1        DELAY_NUM=guc_Read_a[3];
 599   1        DELAY_NUM<<=8;
 600   1        DELAY_NUM+=guc_Read_a[4];
 601   1        if(DELAY_NUM==0||DELAY_NUM>MAX_DELAY)DELAY_NUM=5;
 602   1        
 603   1        //DELAY_NUM<<=2;
 604   1        lightvalue=guc_Read_a[5];
 605   1        //if(lightvalue>100)lightvalue=10;
 606   1        XRBoffbrightvalue = lightvalue;
 607   1        
 608   1        lowlightDELAY_NUM = guc_Read_a[6];
 609   1        if(lowlightDELAY_NUM==0||lowlightDELAY_NUM>255)lowlightDELAY_NUM=1;
 610   1        
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 11  

 611   1        SWITCHfXBR = (guc_Read_a[7])&0x01;
 612   1      //  addr = guc_Read_a[7];
 613   1      //  
 614   1      //  devgroup = guc_Read_a[8];
 615   1      
 616   1      //  addrend = guc_Read_a[9];
 617   1        
 618   1        Flash_ReadArr(0X2f80,1,guc_Read_a1);  //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 619   1        resetbtcnt = guc_Read_a1[0];
 620   1      }
 621          
 622          
 623          void XBRHandle(void)
 624          {
 625   1        //u8 i,j;
 626   1        u16 k;
 627   1      //    if(while_1flag==0)
 628   1      //    send_data(0x55);
 629   1          //while(1)
 630   1          if(while_1flag==0)
 631   1          {
 632   2            //send_data(0x66);
 633   2      //        ADC_TG; 
 634   2      //        while(ADC_IF==0){};
 635   2      //        //adc_data = ADC_DATA_RD();
 636   2      //          
 637   2      //        k = ADC_DH<<8;
 638   2      //        //adc_data =adc_data <<8;
 639   2      //        k+= ADC_DL;
 640   2      //          
 641   2      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
 642   2      
 643   2            ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 644   2            while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
 645   2            ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 646   2            k = ADCR;       //»ñÈ¡ADCµÄÖµ
 647   2            
 648   2            times++;
 649   2            
 650   2            SUM+=k;
 651   2      
 652   2            //¼ÆËãÐÅºÅÖµÓëÖ±Á÷µçÑ¹Æ«²îÖµ
 653   2            if(k>average){k-=average;}
 654   2            else {k=average-k;}
 655   2            SUM1+=k;
 656   2      
 657   2            if((times&0x1ff)==0)
 658   2            {
 659   3              if(LIGHT>0) //????
 660   3              {
 661   4                
 662   4                //LIGHT++;
 663   4                
 664   4                if(slowchcnt<100)
 665   4                {
 666   5                  slowchcnt = slowchcnt+2;//
 667   5                  if(slowchcnt>100)
 668   5                  {
 669   6                    slowchcnt = 100;
 670   6                  }
 671   5                }
 672   4                PWM3init(slowchcnt);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 12  

 673   4              }
 674   3              else if(LIGHT_off ==1)//else if((SWITCHflag2==0)&&(LIGHT_off ==1))
 675   3              {
 676   4                if(slowchcnt>lightvalue)
 677   4                {
 678   5                  if(slowchcnt>=2)slowchcnt-=2;
 679   5                  if(slowchcnt<lightvalue)slowchcnt=lightvalue;
 680   5                }
 681   4                PWM3init(slowchcnt);
 682   4              }
 683   3            }
 684   2            
 685   2            if(times>=8192) //250ms   //12800)  //330ms
 686   2            {
 687   3      
 688   3              WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 689   3              
 690   3              times=0;
 691   3      
 692   3              calc_average_times++;
 693   3            
 694   3              SUM16+=SUM;
 695   3              
 696   3              if(calc_average_times>=8) //Ã¿2.5SÖØÐÂ¼ÆËãÒ»´ÎÖ±Á÷µçÑ¹Öµ
 697   3              {
 698   4                calc_average_times=0;
 699   4                
 700   4                SUM16>>=16;
 701   4                //SUM16/=96000;//102400;
 702   4                average+=SUM16;
 703   4                average/=2;
 704   4                SUM16=0;
 705   4              }
 706   3              
 707   3              if(check_light_times<8) //2s  ¶ÁÈ¡Ò»´Î¸Ð¹âADÖµ
 708   3              {
 709   4                check_light_times++;
 710   4              }
 711   3              else
 712   3              {
 713   4                if(LIGHT==0)  
 714   4                {
 715   5                  //light_ad=READ_LIGHT();
 716   5                  light_ad=read_ad(10);   //ÇÐ»»µ½an10
 717   5      
 718   5                  if((light_ad<=(light_ad0+2))&&(light_ad0<=(light_ad+2)))
 719   5                    light_ad=light_ad0;
 720   5      
 721   5                  light_ad0=light_ad;
 722   5      
 723   5                  check_light_times=0;
 724   5                }
 725   4              }
 726   3      
 727   3              if(SUM0==0)
 728   3              {
 729   4                SUM0=SUM1+5000; 
 730   4                if(start_times==0&&SUM0>1000000)SUM0=1000000;
 731   4              }
 732   3      
 733   3              if(SUM1_counter==0)
 734   3              {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 13  

 735   4                SUM10=SUM1;
 736   4                MAX_DELTA=1;//SUM10>>3;   
 737   4                //if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 738   4              }
 739   3              
 740   3                if((SUM10<(SUM1+MAX_DELTA))&&(SUM1<(SUM10+MAX_DELTA)))//???????????
 741   3                {
 742   4                  SUM1_counter++;
 743   4                  ALL_SUM1+=SUM1;
 744   4                  SUM10=ALL_SUM1/SUM1_counter;
 745   4                  MAX_DELTA=SUM10>>3;
 746   4                  if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 747   4                  if(MAX_DELTA>MAX_DELTA1)MAX_DELTA=MAX_DELTA1;
 748   4                  
 749   4                  if(SUM0>SUM10)
 750   4                  {
 751   5                    SUM=SUM0-SUM10;
 752   5                    if(SUM>80000)SUM0_num=6;
 753   5                    else if(SUM>40000)SUM0_num=9;
 754   5                    else SUM0_num=12;
 755   5                  }
 756   4                  else
 757   4                  {
 758   5                    SUM0_num=12;
 759   5                  }
 760   4                  
 761   4                  if((SUM1_counter>=SUM0_num)&&(SUM10<SUM0))
 762   4                  {
 763   5                    if(SUM1_num>16) //???????????????
 764   5                    {
 765   6                      if(SUM0_num<=9)SUM0=SUM10;
 766   6                      else if(SUM0>(SUM10+4000))
 767   6                      {
 768   7                        SUM0+=SUM10;
 769   7                        SUM0/=2;
 770   7                      }
 771   6                      SUM1_counter=0;
 772   6                      ALL_SUM1=0;
 773   6                    }
 774   5                  }
 775   4      
 776   4                  else if(SUM1_counter>=SUM1_num)
 777   4                  {
 778   5                    
 779   5      //              if(SUM0>SUM10)
 780   5      //              {
 781   5      //                if(SUM1_num>16)SUM0=SUM10;  //???????????????
 782   5      //              }
 783   5      //              else 
 784   5                      
 785   5                    if(SUM10>(SUM0+4000))
 786   5                    {
 787   6                      SUM=SUM10-SUM0;
 788   6      
 789   6                      if((SUM10<8000000)&&(SUM<400000))
 790   6          //????????????,???????????????100000?,???????
 791   6                      {
 792   7                        if(SUM1_num>16) //????????????
 793   7                        {
 794   8                          SUM0+=SUM10;
 795   8                          SUM0/=2;
 796   8                        }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 14  

 797   7                        else
 798   7                        {
 799   8                          if(SUM>300000)SUM1_num=16;
 800   8                          else if(SUM>150000)SUM1_num=12;
 801   8                          else SUM1_num=8;
 802   8                          if(SUM1_counter>=SUM1_num)
 803   8                          {
 804   9                            SUM0+=SUM10;
 805   9                            SUM0/=2;
 806   9                          }
 807   8                        }
 808   7                      }
 809   6                    }
 810   5      //              else if((LIGHT>0)&&(TH==TH_LOW))
 811   5      //              {
 812   5      //                SUM=SUM10-SUM0; 
 813   5      //                TH+=SUM;    //?????????????
 814   5      //              }
 815   5      
 816   5                    if(SUM1_counter>=SUM1_num)
 817   5                    {
 818   6                      SUM1_counter=0;
 819   6                      ALL_SUM1=0;
 820   6                    }
 821   5                  }
 822   4                }
 823   3                else
 824   3                {
 825   4                  SUM1_counter=0;
 826   4                  ALL_SUM1=0;
 827   4                }
 828   3      
 829   3      
 830   3      //        //send_byte=0x35;
 831   3      //        check_sum=0xFa;
 832   3              //send_data(0xFa);
 833   3      
 834   3      //        send_byte=TH>>15;
 835   3      //        check_sum+=send_byte;
 836   3      //        send_data(send_byte);
 837   3      
 838   3      //        //k=TH;
 839   3      //        send_byte=TH>>10;
 840   3      //        check_sum+=send_byte;
 841   3      //        send_data(send_byte);
 842   3      //          
 843   3      //        send_byte=LIGHT_TH;
 844   3      //        check_sum+=send_byte;
 845   3      //        send_data(send_byte);         
 846   3      
 847   3      //        //send_byte=light_ad;
 848   3      //        check_sum+=light_ad;
 849   3      //        send_data(light_ad);
 850   3      
 851   3      //        send_byte=average>>4;
 852   3      //        check_sum+=send_byte;
 853   3      //        send_data(send_byte);
 854   3      
 855   3      //        send_byte=SUM0>>16;
 856   3      //        check_sum+=send_byte;
 857   3      //        send_data(send_byte);
 858   3      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 15  

 859   3      //        send_byte=SUM0>>8;
 860   3      //        check_sum+=send_byte;
 861   3      //        send_data(send_byte);
 862   3      
 863   3      //        send_byte=SUM1>>16;
 864   3      //        check_sum+=send_byte;
 865   3      //        send_data(send_byte);
 866   3      
 867   3      //        send_byte=SUM1>>8;
 868   3      //        check_sum+=send_byte;
 869   3      //        send_data(send_byte);
 870   3      
 871   3      //        check_sum+=1;
 872   3      //        send_data(check_sum);
 873   3      
 874   3              if(stop_times>0)  //
 875   3              {
 876   4                stop_times--; 
 877   4                if((SUM0>(SUM01+6000))&&(SUM1<(SUM01+15000)))SUM0=SUM01+6000;
 878   4              }
 879   3              else
 880   3              {
 881   4              
 882   4                if(start_times>0)
 883   4                {
 884   5                  start_times--;
 885   5                  
 886   5                  if(start_times>0) //???????????,???????250*88ms=22S?????????          
 887   5                  {
 888   6                    //start_times++;
 889   6      /*
 890   6                    if(SUM0>600000)
 891   6                    {
 892   6                      TH=10000;
 893   6                    }
 894   6                    else */
 895   6                    if(SUM0>8000000)
 896   6                    {
 897   7                      TH=800000;
 898   7                    }
 899   6                    else
 900   6                    {
 901   7                      SUM=SUM0+TH;
 902   7                      if(SUM>9000000)
 903   7                      {
 904   8                        TH=9000000-SUM0;
 905   8                      }
 906   7                      //if(TH<30000)TH=30000;
 907   7                    }
 908   6      
 909   6                  }
 910   5                  else
 911   5                  {
 912   6                    //TH=TH_LOW;
 913   6                    //start_times=0;
 914   6      //              EA=0;
 915   6      //              set_var();
 916   6      //              EA=1;
 917   6                  }
 918   5      
 919   5                }
 920   4      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 16  

 921   4                if(SUM1>(SUM0+TH))
 922   4                {
 923   5                  //SUM=SUM1-SUM0;
 924   5      
 925   5                //  if(SUM>TH)
 926   5                //  {
 927   5                    if((light_ad<=LIGHT_TH)||(start_times>0))
 928   5                    {
 929   6      //                send_data(0xaa);
 930   6      
 931   6                      
 932   6                      //if(alarm_times<2)
 933   6                      //{
 934   6                      //  alarm_times++;
 935   6                    //    }
 936   6                      //if(alarm_times>=2)  //??????????????
 937   6                      {
 938   7                        if(LIGHT==0)SUM01=SUM0;
 939   7                        LIGHT=1;
 940   7                        Light_on_flag = 1;
 941   7                        //PC3=0;
 942   7                        //LIGHT_ON;
 943   7                        //slowchcnt = slowchcnt+20;//
 944   7                        //if(slowchcnt>100)
 945   7                        //{
 946   7                        //  slowchcnt = 100;
 947   7                        //}
 948   7                        //PWM3init(slowchcnt);
 949   7                        //P0_6=0;
 950   7      //                  send_data(0xaa);
 951   7      //                  send_data((TH/1000)>>8);
 952   7      //                  send_data((TH/1000)&0xff);
 953   7      //                  send_data(LIGHT_TH);
 954   7      //                  send_data(DELAY_NUM>>10);
 955   7      //                  send_data(DELAY_NUM>>2);    //²âÊÔÓÃ
 956   7      //                  send_data(slowchcnt);
 957   7      //                  send_data(0xaa);  
 958   7                        send_data(0xdd);
 959   7      
 960   7                        SUM1_num=8;
 961   7                        LIGHT_off=0;
 962   7                        light1scount=0;
 963   7                        light1sflag=0;
 964   7        //                send_data(0xaa);
 965   7      
 966   7                      }
 967   6                    }
 968   5                
 969   5                  }
 970   4      
 971   4              }
 972   3      
 973   3              SUM2=SUM1;
 974   3              send_data(average>>4);
 975   3              send_data(light_ad);
 976   3              send_data(SUM0>>16);
 977   3              send_data(SUM0>>8);
 978   3              send_data(SUM2>>16);
 979   3              send_data(SUM2>>8);     //20200927  ²âÊÔÓÃ        
 980   3              
 981   3              SUM=0;
 982   3              SUM1=0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 17  

 983   3              
 984   3              if(LIGHT>0) //????
 985   3              {
 986   4                
 987   4                //LIGHT++;
 988   4                
 989   4      //          slowchcnt = slowchcnt+5;//
 990   4      //          if(slowchcnt>=100)
 991   4      //          {
 992   4      //            slowchcnt = 100;
 993   4      //          }
 994   4      //          PWM3init(slowchcnt);
 995   4                
 996   4                if(LIGHT>DELAY_NUM)
 997   4                {
 998   5                  LIGHT=0;
 999   5                  while_1flag=1;
1000   5                  Light_on_flag=0;
1001   5                  Light_on_flagpre=0;
1002   5                  //while_2flag = 0;
1003   5                  //break;
1004   5                }
1005   4              }
1006   3              
1007   3              
1008   3            }
1009   2      
1010   2      
1011   2          }
1012   1          else
1013   1          {
1014   2              LIGHT_off = 1;
1015   2              while_1flag=0;
1016   2              //if(while_2flag==0)
1017   2              //{
1018   2              //  while_2flag = 1;
1019   2      //          send_data(0x55);
1020   2              //}
1021   2              //PC3=1;
1022   2              //LIGHT_OFF;
1023   2              //slowchcnt = lightvalue;
1024   2              //PWM3init(lightvalue);
1025   2              lowlight1mincount = 0;
1026   2              lowlight1minflag = 0;
1027   2              
1028   2            
1029   2              //P0_6=1;
1030   2              //send_data(0x55);
1031   2              Delay_ms(250);
1032   2      
1033   2      
1034   2              
1035   2          //    SUM=0;
1036   2          //    SUM1=0;
1037   2          //    times=0;
1038   2              
1039   2              SUM16=0;
1040   2              calc_average_times=0;
1041   2              SUM1_num=64;
1042   2              
1043   2              stop_times=2;
1044   2              //if(start_times==0)TH=TH_LOW;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 18  

1045   2              check_light_times=6;
1046   2              
1047   2              SUM1_counter=0;
1048   2              ALL_SUM1=0;
1049   2      
1050   2          //    send_data(0xdd);
1051   2          //    send_data(0xdd);
1052   2          }
1053   1      
1054   1      }
1055          
1056          
1057          void wait1(void)
1058          {
1059   1        u8 i,j;
1060   1      
1061   1        //µÈ´ýÖ±Á÷µçÑ¹ÎÈ¶¨
1062   1        j=0;
1063   1        while(1)
1064   1        {
1065   2          SUM=0;
1066   2          
1067   2          
1068   2      //    for(i=0;i<4;i++)  //0.52s
1069   2      //    {
1070   2      //      for(t=0;t<8192;t++) //0.13s
1071   2      //      {
1072   2      
1073   2      //        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1074   2      //        while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1075   2      //        ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1076   2      //        k = ADCR;       //»ñÈ¡ADCµÄÖµ
1077   2      //        
1078   2      //        SUM+=k;
1079   2      //  
1080   2      //      }
1081   2      //      
1082   2      //      WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1083   2            
1084   2      
1085   2            for(i=0;i<128;i++)  //
1086   2            {
1087   3      
1088   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1089   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1090   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1091   3              //k = ADCR;       //»ñÈ¡ADCµÄÖµ
1092   3              
1093   3              SUM+=ADCR;
1094   3              
1095   3            }
1096   2      
1097   2      //·¢ËÍ¸Ð¹âADÖµ
1098   2      //        send_byte=0xFA;
1099   2      //        check_sum=send_byte;
1100   2      //        send_data(send_byte);
1101   2      
1102   2      //        //send_byte=light_ad;
1103   2      //        check_sum+=light_ad;
1104   2      //        send_data(light_ad);
1105   2      
1106   2      //        check_sum+=light_ad;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 19  

1107   2      //        send_data(light_ad);
1108   2      //        
1109   2      //        check_sum+=1;
1110   2      //        send_data(check_sum);
1111   2      
1112   2      
1113   2      
1114   2        //}
1115   2          
1116   2          Delay_ms(400);
1117   2            
1118   2      
1119   2          
1120   2          //WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1121   2      
1122   2          i=SUM>>11;
1123   2          if((i>12)&&(i<141)&&(j>20))break;
1124   2      
1125   2          j++;
1126   2      
1127   2          if(j>80)break;  //??35????????????1.1V???????
1128   2      
1129   2        }
1130   1      }
1131          void wait2(void)
1132          {
1133   1        u8 i;
1134   1        //u8 j;
1135   1        u16 k,t;
1136   1      
1137   1        SUM=0;
1138   1      
1139   1      
1140   1          for(i=0;i<8;i++)
1141   1          {
1142   2            for(t=0;t<8192;t++) 
1143   2            {
1144   3      //        ADC_TG; 
1145   3      //        while(ADC_IF==0){};
1146   3      //        //adc_data = ADC_DATA_RD();
1147   3      //          
1148   3      //        k = ADC_DH<<8;
1149   3      //        //adc_data =adc_data <<8;
1150   3      //        k+= ADC_DL;
1151   3      //          
1152   3      //        ADC_INT_IF_CLR; //ÇåÖÐ¶Ï±êÖ¾Î»
1153   3          
1154   3              ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1155   3              while(!(ADCC0&0x20));   //µÈ´ýADC×ª»»½áÊø
1156   3              ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
1157   3              k = ADCR;       //»ñÈ¡ADCµÄÖµ
1158   3              
1159   3              SUM+=k;
1160   3        
1161   3            }
1162   2            WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1163   2      
1164   2          }
1165   1      
1166   1          average=SUM>>16;
1167   1      
1168   1      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 20  

1169   1      //  light_ad=read_ad(10);
1170   1      //  light_ad0=light_ad;
1171   1      
1172   1      //  Delay_ms(4);  //4ms
1173   1      }
1174          
1175          unsigned char PWM3init(unsigned char ab)
1176          {
1177   1         float i11;
1178   1        unsigned char j11;
1179   1        i11=ab*255/100;
1180   1        j11=i11;
1181   1        #ifdef V11
              /************************************PWM3³õÊ¼»¯****************************************/
                //P0M3 = P0M3&0xF0|0x08;    //P06ÉèÖÃÎªÍÆÍìÊä³ö
                PWM3_MAP = 0x05;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1187   1        
1188   1        #ifdef V10
                PWM3_MAP = 0x06;          //PWM3Ó³ÉäP05¿Ú
                
                #endif
1192   1      
1193   1        #ifdef V12
1194   1        PWM3_MAP = 0x10;          //PWM3Ó³ÉäP10¿Ú
1195   1        
1196   1        #endif  
1197   1        
1198   1          //ÖÜÆÚ¼ÆËã  = 0xFF / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1199   1        //      = 0xFF /(16000000 / 4)      
1200   1        //      = 255 /4000000
1201   1        //      = 63.75us   ¼´15.69KHZ    
1202   1      
1203   1        PWM3P = 0xFF;             //PWMÖÜÆÚÎª0xFF
1204   1        //ÓÐÐ§µçÆ½Ê±¼ä¼ÆËã£¨¼´Õ¼¿Õ±È£©  
1205   1        //      = 0x55 / (Fosc / PWM·ÖÆµÏµÊý)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1206   1        //      = 0x55 /(16000000 / 4)      
1207   1        //      = 85 /4000000
1208   1        //      = 21.25us   Õ¼¿Õ±ÈÎª 21.25 / 63.75 = 34%
1209   1      
1210   1        PWM3D = j11;              //PWMÕ¼¿Õ±ÈÉèÖÃ
1211   1        PWM3C = 0x94;             //Ê¹ÄÜPWM3£¬¹Ø±ÕÖÐ¶Ï£¬ÔÊÐíÊä³ö£¬Ê±ÖÓ16·ÖÆµ
1212   1        
1213   1        return 0;
1214   1      }
1215          
1216          /***************************************************************************************
1217            * @ËµÃ÷   Ö÷º¯Êý
1218            * @²ÎÊý   ÎÞ
1219            * @·µ»ØÖµ ÎÞ
1220            * @×¢     ÎÞ
1221          ***************************************************************************************/
1222          void main()
1223          {
1224   1        u8 i;
1225   1        bt_protocol_init();   //mcu_sdk
1226   1        InitSYS();
1227   1        GPIO_Init();
1228   1        //LIGHT_ON;
1229   1        //P0_6=0;
1230   1        PWM3init(100);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 21  

1231   1        Timer_Init();
1232   1        UART1_Init();
1233   1        ADC_Init();
1234   1      
1235   1        LVDC = 0xAA;              //LVDÉèÖÃ2.4V,½ûÖ¹ÖÐ¶Ï
1236   1        //  Ïû¶¶Ê±¼ä =  (0xFF + 2) * 1/Fcpu
1237   1        //       =  (0xFF + 2) / 16000000 £¨µ±Ç°µÄCPUÊ±ÖÓ£©
1238   1        //       =  16.0625us
1239   1        LVDDBC = 0xFF;            //ÉèÖÃÏû¶¶Ê±¼ä
1240   1        LVDC &=~ 0x08;            //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»   
1241   1      //  
1242   1        EA=1;
1243   1        
1244   1        Delay_ms(200);
1245   1        
1246   1        //LIGHT_ON;
1247   1        PWM3init(100);
1248   1        SWITCHflag = 1;
1249   1        light_ad=read_ad(10);
1250   1        light_ad0=light_ad;
1251   1        
1252   1        EA=0;
1253   1        set_var();  //´Óflash¶ÁÈ¡³ö±äÁ¿
1254   1        
1255   1        //for(i=0;i<5;i++)send_data(guc_Read_a[i]);
1256   1        
1257   1      //  TXdata[0]=VERSION;
1258   1      //  t=TH/1000;
1259   1      //  TXdata[1]=t>>8;
1260   1      //  TXdata[2]=t;
1261   1      //  TXdata[3]=LIGHT_TH;
1262   1      //  t=DELAY_NUM/4;
1263   1      //  TXdata[4]=t>>8;
1264   1      //  TXdata[5]=t;
1265   1      
1266   1      //  TXdata[6]=light_ad;
1267   1      
1268   1      //  for(i=0;i<7;i++)send_data(TXdata[i]); 
1269   1        resetbtcnt++;
1270   1        
1271   1        Flash_EraseBlock(0x2F80);
1272   1        Delay_us_1(10000);
1273   1        FLASH_WriteData(resetbtcnt, 0x2F80);
1274   1        Delay_us_1(100);
1275   1        
1276   1        EA=1;
1277   1        
1278   1        wait1();
1279   1      
1280   1        slowchcnt = lightvalue;
1281   1        //Delay_ms(200);
1282   1        PWM3init(lightvalue);
1283   1        //LIGHT_OFF;
1284   1        //P0_6=1;
1285   1        Delay_ms(300);
1286   1        
1287   1        wait2();
1288   1      
1289   1        SUM=0;
1290   1        while(1)
1291   1        {
1292   2          if(resetbtcnt>=3)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 22  

1293   2          {
1294   3            resetbtcnt = 0;
1295   3            send_data(0x55);//p15£¬ÖØÖÃÄ£¿é
1296   3            send_data(0xAA);
1297   3            send_data(0X00);
1298   3            send_data(0X04);
1299   3            send_data(0X00);
1300   3            send_data(0X00);
1301   3            send_data(0X03);
1302   3            
1303   3          }
1304   2          if(check_group_count <=2)//Ò»ÉÏµç¼ä¸ôÒ»Ãë»ñÈ¡3´ÎÈº×éµØÖ·
1305   2          {
1306   3            if(check_group_flag == 1)
1307   3            {
1308   4                check_group_flag = 0;
1309   4                check_group_count ++;
1310   4              
1311   4                send_data(0x55);
1312   4                send_data(0xAA);
1313   4                send_data(0X00);
1314   4                send_data(0XB4);
1315   4                send_data(0X00);
1316   4                send_data(0X00);
1317   4                send_data(0Xb3);
1318   4              
1319   4            
1320   4            }
1321   3            
1322   3          
1323   3          }
1324   2          WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1325   2          
1326   2          
1327   2          if(while_1flag==0)
1328   2          {
1329   3            if((times&0x1f)==0)
1330   3              bt_uart_service();
1331   3          }
1332   2          
1333   2          if(SWITCHfXBR==1)//À×´ï¿ª, app¿ØÖÆ
1334   2          {
1335   3            if(while_2flag==0)
1336   3            {
1337   4              while_1flag=0;
1338   4      
1339   4              while_2flag = 1;
1340   4              slowchcnt = lightvalue;
1341   4      
1342   4              
1343   4              SUM16=0;
1344   4              calc_average_times=0;
1345   4              SUM1_num=64;
1346   4              
1347   4              stop_times=2;
1348   4              //if(start_times==0)TH=TH_LOW;
1349   4              check_light_times=6;
1350   4              
1351   4              SUM1_counter=0;
1352   4              ALL_SUM1=0;
1353   4            }
1354   3            
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 23  

1355   3            XBRHandle();
1356   3            
1357   3            if(LIGHT_off>0)//¹ØµÆÑÓÊ±
1358   3            {
1359   4              if(lowlight1minflag==1)
1360   4              {
1361   5                lowlight1minflag = 0;
1362   5                LIGHT_off++;
1363   5                if(LIGHT_off>=lowlightDELAY_NUM)
1364   5                {
1365   6                  LIGHT_off=0;
1366   6                  PWM3init(0);
1367   6      
1368   6                }
1369   5              }
1370   4            }
1371   3            if(LIGHT>0)//ÁÁµÆÑÓÊ±
1372   3            {
1373   4              if(light1sflag==1)
1374   4              {
1375   5                light1sflag = 0;
1376   5                LIGHT++;
1377   5                //slowchcnt = slowchcnt+20;//
1378   5      //          if(slowchcnt>100)
1379   5      //          {
1380   5      //            slowchcnt = 100;
1381   5      //          }
1382   5      //          PWM3init(slowchcnt);
1383   5              }
1384   4            }
1385   3      
1386   3            //Áª¶¯
1387   3            if(Linkage_flag==1)
1388   3            {
1389   4              if(Light_on_flagpre!=Light_on_flag)
1390   4              {
1391   5                Light_on_flagpre = Light_on_flag;
1392   5                LIGHT = 1;
1393   5                //PWM3init(100);
1394   5                for(i=0;i<8;i++)
1395   5                {
1396   6                  if(groupaddr[i] != 0)
1397   6                  {
1398   7                    mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,SWITCHflag2,groupaddr[i]);
1399   7                  } 
1400   6                }
1401   5      
1402   5      
1403   5              }
1404   4      
1405   4            } 
1406   3            
1407   3          }
1408   2          else
1409   2          {//À×´ï¹Ø
1410   3            while_2flag = 0;
1411   3            if(SWITCHflag2==0)//¹ØµÆ
1412   3            {
1413   4              PWM3init(0);
1414   4            }
1415   3            else
1416   3            {//¹ØµÆ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 24  

1417   4              PWM3init(XRBoffbrightvalue);
1418   4              
1419   4              while_1flag=0;
1420   4      
1421   4              slowchcnt = lightvalue;
1422   4              //PWM3init(lightvalue);
1423   4      
1424   4              
1425   4              SUM16=0;
1426   4              calc_average_times=0;
1427   4              SUM1_num=64;
1428   4              
1429   4              stop_times=2;
1430   4              //if(start_times==0)TH=TH_LOW;
1431   4              check_light_times=6;
1432   4              
1433   4              SUM1_counter=0;
1434   4              ALL_SUM1=0;
1435   4              
1436   4            }
1437   3            
1438   3          
1439   3          }
1440   2      
1441   2        } 
1442   1        
1443   1      //  while(1)
1444   1      //  {
1445   1      //    System_Time_Cnt();
1446   1      //    System_Task();
1447   1      //    WDTC |= 0x10;              //Çå¹·
1448   1      //  }
1449   1      
1450   1        
1451   1        
1452   1      }
1453          
1454          /***************************************************************************************
1455            * @ËµÃ÷   T1ÖÐ¶Ï·þÎñº¯Êý
1456            * @²ÎÊý   ÎÞ
1457            * @·µ»ØÖµ ÎÞ
1458            * @×¢     ÎÞ
1459          ***************************************************************************************/
1460          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR
1461          {
1462   1        //Timer1_FLAG = 1;    //1mS
1463   1        Timer_Counter++;
1464   1      
1465   1        lowlight1mincount++;
1466   1        if(lowlight1mincount>=60000)
1467   1        {
1468   2          lowlight1mincount = 0;
1469   2          lowlight1minflag = 1;
1470   2        }
1471   1        light1scount++;
1472   1        if(light1scount>=1000)
1473   1        {
1474   2          check_group_flag = 1;
1475   2          light1scount=0;
1476   2          light1sflag=1;
1477   2        }
1478   1      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 25  

1479   1        
1480   1      }
1481          
1482          /***************************************************************************************
1483            * @ËµÃ÷   UART1ÖÐ¶Ï·þÎñº¯Êý
1484            * @²ÎÊý   ÎÞ
1485            * @·µ»ØÖµ ÎÞ
1486            * @×¢     ÎÞ
1487          ***************************************************************************************/
1488          
1489          void UART1_Rpt(void) interrupt UART1_VECTOR
1490          {
1491   1        u8 i;
1492   1        //u16 t;
1493   1        
1494   1        if(SCON & 0x01)                       //ÅÐ¶Ï½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1495   1        {
1496   2            i=SBUF;
1497   2            uart_receive_input(i);
1498   2            SCON &=~ 0x01;                    //Çå³ý½ÓÊÕÖÐ¶Ï±êÖ¾Î»
1499   2            EA=1;
1500   2        }
1501   1      }
1502          
1503          void UART2_Rpt(void) interrupt UART2_VECTOR
1504          {
1505   1      }
1506          
1507          // void Delay_2us(u16 Cnt)
1508          // {
1509          //  while(Cnt--); 
1510          // }
1511          
1512          void Flash_EraseBlock(unsigned int fui_Address)
1513          {
1514   1        while(1)
1515   1        {
1516   2          LVDC &=~ 0x08;        //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1517   2          P0_0=0;   
1518   2          if((LVDC&0x08)==0)    break;
1519   2        }
1520   1        P0_0=1;   
1521   1        EA=0;
1522   1        IAP_CMD = 0xF00F;       //Flash½âËø
1523   1        IAP_ADDR = fui_Address; //Ð´Èë²Á³ýµØÖ·
1524   1        IAP_CMD = 0xD22D;       //Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ý
1525   1        IAP_CMD = 0xE11E;       //´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
1526   1        //EA=1;
1527   1      }
1528          
1529          /**
1530            * @ËµÃ÷   Ð´ÈëÒ»¸ö×Ö½ÚÊý¾Ýµ½FlashÀïÃæ
1531            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1532            * @²ÎÊý   fui_Address £ºFLASHµØÖ·
1533            * @²ÎÊý   fucp_SaveData£ºÐ´ÈëµÄÊý¾Ý
1534            * @·µ»ØÖµ ÎÞ
1535            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1536            */
1537          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
1538          {
1539   1        while(1)
1540   1        {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        10/13/2020 14:51:02 PAGE 26  

1541   2          LVDC &=~ 0x08;         //Çå³ýLVDÖÐ¶Ï±êÖ¾Î»
1542   2          P0_0=0;   
1543   2          if((LVDC&0x08)==0)    break;
1544   2        }
1545   1        P0_0=1; 
1546   1        EA=0;
1547   1        IAP_DATA = fuc_SaveData;
1548   1        IAP_CMD=0xF00F;          //Flash½âËø
1549   1        IAP_ADDR = fui_Address;
1550   1        IAP_CMD=0xB44B;          //×Ö½Ú±à³Ì
1551   1        IAP_CMD=0xE11E;          //´¥·¢Ò»´Î²Ù×÷
1552   1        //EA=1;
1553   1      }
1554          
1555          /**
1556            * @ËµÃ÷   Ð´ÈëÈÎÒâ³¤¶ÈµÄÊý¾Ýµ½FLASHÀïÃæ
1557            *         ¸Ãº¯ÊýÐè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1558            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1559            * @²ÎÊý   fuc_Length £º Ð´ÈëÊý¾Ý³¤¶È
1560            *         È¡Öµ·¶Î§£º0x00-0xFF
1561            * @²ÎÊý  *fucp_SaveArr£ºÐ´ÈëµÄÊý¾Ý´æ·ÅÇøÓòµÄÊ×µØÖ·
1562            * @·µ»ØÖµ ÎÞ
1563            * @×¢     Ð´Ö®Ç°±ØÐëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øÐÐ²Á³ý
1564            */
1565          
1566          // void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
1567          // {
1568          //  unsigned char fui_i = 0;
1569          //  EA=0;
1570          //  for(fui_i=0;fui_i<fuc_Length;fui_i++)
1571          //  {
1572          //    FLASH_WriteData(*(fucp_SaveArr++), fui_Address++); 
1573          //  }
1574          //  EA=1;
1575          // }
1576          
1577          /**
1578            * @ËµÃ÷   ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊý¾Ý
1579            * @²ÎÊý   fui_Address £ºFLASHÆðÊ¼µØÖ·
1580            * @²ÎÊý   fuc_Length £º¶ÁÈ¡Êý¾Ý³¤¶È
1581            *         È¡Öµ·¶Î§£º0x00-0xFF
1582            * @²ÎÊý  *fucp_SaveArr£º¶ÁÈ¡Êý¾Ý´æ·ÅµÄÇøÓòÊ×µØÖ·
1583            * @·µ»ØÖµ ÎÞ
1584            * @×¢     ÎÞ
1585            */
1586          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4369    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     91    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      15
   IDATA SIZE       =     25    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
